"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(editor)/editor/page",{

/***/ "(app-pages-browser)/./src/lib/ai-service.ts":
/*!*******************************!*\
  !*** ./src/lib/ai-service.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIService: () => (/* binding */ AIService),\n/* harmony export */   aiService: () => (/* binding */ aiService)\n/* harmony export */ });\nclass AIService {\n    // 자동 태그 생성 (Mock 구현)\n    async generateTags(content, title) {\n        // 실제로는 OpenAI API를 사용하지만, 여기서는 Mock 구현\n        const mockTags = [];\n        // 키워드 기반 태그 생성\n        const keywords = this.extractKeywords(content + ' ' + title);\n        keywords.forEach((keyword)=>{\n            const confidence = Math.random() * 0.4 + 0.6 // 0.6-1.0\n            ;\n            mockTags.push({\n                tag: keyword,\n                confidence,\n                reason: '문서에서 \"'.concat(keyword, '\" 키워드가 자주 사용됨')\n            });\n        });\n        // 카테고리 기반 태그 생성\n        const categories = this.detectCategories(content);\n        categories.forEach((category)=>{\n            mockTags.push({\n                tag: category,\n                confidence: Math.random() * 0.3 + 0.7,\n                reason: '문서 내용이 \"'.concat(category, '\" 카테고리에 해당함')\n            });\n        });\n        return mockTags.sort((a, b)=>b.confidence - a.confidence);\n    }\n    // 의미론적 검색 (Mock 구현)\n    async semanticSearch(query, documents) {\n        const results = [];\n        documents.forEach((doc)=>{\n            const relevanceScore = this.calculateRelevance(query, doc);\n            if (relevanceScore > 0.1) {\n                results.push({\n                    ...doc,\n                    relevanceScore,\n                    matchedTerms: this.findMatchedTerms(query, doc)\n                });\n            }\n        });\n        return results.sort((a, b)=>b.relevanceScore - a.relevanceScore);\n    }\n    // 문서 요약 생성\n    async generateSummary(content) {\n        // Mock 구현 - 실제로는 AI API 사용\n        const sentences = content.split(/[.!?]+/).filter((s)=>s.trim().length > 10);\n        const summary = sentences.slice(0, 2).join('. ');\n        return summary + (sentences.length > 2 ? '...' : '');\n    }\n    // 문서 관계 분석\n    async analyzeDocumentRelationships(documents) {\n        const relationships = [];\n        for(let i = 0; i < documents.length; i++){\n            for(let j = i + 1; j < documents.length; j++){\n                const doc1 = documents[i];\n                const doc2 = documents[j];\n                const similarity = this.calculateSimilarity(doc1, doc2);\n                if (similarity > 0.3) {\n                    relationships.push({\n                        source: doc1.title,\n                        target: doc2.title,\n                        relationship: this.determineRelationship(doc1, doc2),\n                        strength: similarity\n                    });\n                }\n            }\n        }\n        return relationships;\n    }\n    // 키워드 추출 (Mock)\n    extractKeywords(text) {\n        const words = text.toLowerCase().replace(/[^\\w\\s가-힣]/g, ' ').split(/\\s+/).filter((word)=>word.length > 2);\n        const wordCount = new Map();\n        words.forEach((word)=>{\n            wordCount.set(word, (wordCount.get(word) || 0) + 1);\n        });\n        return Array.from(wordCount.entries()).filter((param)=>{\n            let [_, count] = param;\n            return count > 1;\n        }).sort((param, param1)=>{\n            let [, a] = param, [, b] = param1;\n            return b - a;\n        }).slice(0, 5).map((param)=>{\n            let [word, _] = param;\n            return word;\n        });\n    }\n    // 카테고리 감지 (Mock)\n    detectCategories(content) {\n        const categories = [];\n        const text = content.toLowerCase();\n        if (text.includes('api') || text.includes('endpoint') || text.includes('rest')) {\n            categories.push('API');\n        }\n        if (text.includes('설치') || text.includes('setup') || text.includes('환경')) {\n            categories.push('설치');\n        }\n        if (text.includes('문서') || text.includes('documentation') || text.includes('가이드')) {\n            categories.push('문서');\n        }\n        if (text.includes('프로젝트') || text.includes('project') || text.includes('개요')) {\n            categories.push('프로젝트');\n        }\n        if (text.includes('개발') || text.includes('development') || text.includes('코드')) {\n            categories.push('개발');\n        }\n        return categories;\n    }\n    // 관련성 계산 (Mock)\n    calculateRelevance(query, doc) {\n        const queryTerms = query.toLowerCase().split(/\\s+/);\n        let score = 0;\n        // 제목 매칭 (높은 가중치)\n        queryTerms.forEach((term)=>{\n            if (doc.title.toLowerCase().includes(term)) {\n                score += 0.4;\n            }\n            if (doc.description.toLowerCase().includes(term)) {\n                score += 0.2;\n            }\n            if (doc.tags.some((tag)=>tag.toLowerCase().includes(term))) {\n                score += 0.3;\n            }\n        });\n        return Math.min(score, 1.0);\n    }\n    // 매칭된 용어 찾기\n    findMatchedTerms(query, doc) {\n        const queryTerms = query.toLowerCase().split(/\\s+/);\n        const matchedTerms = [];\n        queryTerms.forEach((term)=>{\n            if (doc.title.toLowerCase().includes(term) || doc.description.toLowerCase().includes(term) || doc.tags.some((tag)=>tag.toLowerCase().includes(term))) {\n                matchedTerms.push(term);\n            }\n        });\n        return matchedTerms;\n    }\n    // 문서 유사도 계산\n    calculateSimilarity(doc1, doc2) {\n        // 태그 유사도\n        const tags1 = new Set(doc1.tags);\n        const tags2 = new Set(doc2.tags);\n        const commonTags = new Set([\n            ...tags1\n        ].filter((tag)=>tags2.has(tag)));\n        const tagSimilarity = commonTags.size / Math.max(tags1.size, tags2.size);\n        // 제목 유사도 (간단한 문자열 유사도)\n        const titleSimilarity = this.stringSimilarity(doc1.title, doc2.title);\n        return tagSimilarity * 0.6 + titleSimilarity * 0.4;\n    }\n    // 문자열 유사도 계산 (간단한 구현)\n    stringSimilarity(str1, str2) {\n        const words1 = str1.toLowerCase().split(/\\s+/);\n        const words2 = str2.toLowerCase().split(/\\s+/);\n        const commonWords = words1.filter((word)=>words2.includes(word));\n        return commonWords.length / Math.max(words1.length, words2.length);\n    }\n    // 관계 유형 결정\n    determineRelationship(doc1, doc2) {\n        const tags1 = new Set(doc1.tags);\n        const tags2 = new Set(doc2.tags);\n        const commonTags = [\n            ...tags1\n        ].filter((tag)=>tags2.has(tag));\n        if (commonTags.includes('API') && commonTags.includes('문서')) {\n            return 'API 문서 관계';\n        }\n        if (commonTags.includes('설치') && commonTags.includes('개발')) {\n            return '개발 환경 관계';\n        }\n        if (commonTags.includes('프로젝트') && commonTags.includes('문서')) {\n            return '프로젝트 문서 관계';\n        }\n        return '관련 문서';\n    }\n    constructor(apiKey){\n        this.apiKey = null;\n        this.apiKey = apiKey || null;\n    }\n}\n// 싱글톤 인스턴스\nconst aiService = new AIService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWktc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQTBCTyxNQUFNQTtJQU9YLHFCQUFxQjtJQUNyQixNQUFNQyxhQUFhQyxPQUFlLEVBQUVDLEtBQWEsRUFBOEI7UUFDN0UsdUNBQXVDO1FBQ3ZDLE1BQU1DLFdBQThCLEVBQUU7UUFFdEMsZUFBZTtRQUNmLE1BQU1DLFdBQVcsSUFBSSxDQUFDQyxlQUFlLENBQUNKLFVBQVUsTUFBTUM7UUFFdERFLFNBQVNFLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDZixNQUFNQyxhQUFhQyxLQUFLQyxNQUFNLEtBQUssTUFBTSxJQUFJLFVBQVU7O1lBQ3ZEUCxTQUFTUSxJQUFJLENBQUM7Z0JBQ1pDLEtBQUtMO2dCQUNMQztnQkFDQUssUUFBUSxTQUFpQixPQUFSTixTQUFRO1lBQzNCO1FBQ0Y7UUFFQSxnQkFBZ0I7UUFDaEIsTUFBTU8sYUFBYSxJQUFJLENBQUNDLGdCQUFnQixDQUFDZDtRQUN6Q2EsV0FBV1IsT0FBTyxDQUFDVSxDQUFBQTtZQUNqQmIsU0FBU1EsSUFBSSxDQUFDO2dCQUNaQyxLQUFLSTtnQkFDTFIsWUFBWUMsS0FBS0MsTUFBTSxLQUFLLE1BQU07Z0JBQ2xDRyxRQUFRLFdBQW9CLE9BQVRHLFVBQVM7WUFDOUI7UUFDRjtRQUVBLE9BQU9iLFNBQVNjLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFWCxVQUFVLEdBQUdVLEVBQUVWLFVBQVU7SUFDNUQ7SUFFQSxvQkFBb0I7SUFDcEIsTUFBTVksZUFBZUMsS0FBYSxFQUFFQyxTQUF5QixFQUE2QjtRQUN4RixNQUFNQyxVQUE0QixFQUFFO1FBRXBDRCxVQUFVaEIsT0FBTyxDQUFDa0IsQ0FBQUE7WUFDaEIsTUFBTUMsaUJBQWlCLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNMLE9BQU9HO1lBQ3RELElBQUlDLGlCQUFpQixLQUFLO2dCQUN4QkYsUUFBUVosSUFBSSxDQUFDO29CQUNYLEdBQUdhLEdBQUc7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WXRELE1BQU0sR0FBRzFCLEtBQUt5RSxHQUFHLENBQUNLLE9BQU9wRCxNQUFNLEVBQUVxRCxPQUFPckQsTUFBTTtJQUNuRTtJQUVBLFdBQVc7SUFDSGUsc0JBQXNCUCxJQUFrQixFQUFFQyxJQUFrQixFQUFVO1FBQzVFLE1BQU0rQixRQUFRLElBQUlDLElBQUlqQyxLQUFLNkIsSUFBSTtRQUMvQixNQUFNSyxRQUFRLElBQUlELElBQUloQyxLQUFLNEIsSUFBSTtRQUMvQixNQUFNTSxhQUFhO2VBQUlIO1NBQU0sQ0FBQzNDLE1BQU0sQ0FBQ3BCLENBQUFBLE1BQU9pRSxNQUFNRSxHQUFHLENBQUNuRTtRQUV0RCxJQUFJa0UsV0FBV1gsUUFBUSxDQUFDLFVBQVVXLFdBQVdYLFFBQVEsQ0FBQyxPQUFPO1lBQzNELE9BQU87UUFDVDtRQUNBLElBQUlXLFdBQVdYLFFBQVEsQ0FBQyxTQUFTVyxXQUFXWCxRQUFRLENBQUMsT0FBTztZQUMxRCxPQUFPO1FBQ1Q7UUFDQSxJQUFJVyxXQUFXWCxRQUFRLENBQUMsV0FBV1csV0FBV1gsUUFBUSxDQUFDLE9BQU87WUFDNUQsT0FBTztRQUNUO1FBRUEsT0FBTztJQUNUO0lBck5BdUIsWUFBWUMsTUFBZSxDQUFFO2FBRnJCQSxTQUF3QjtRQUc5QixJQUFJLENBQUNBLE1BQU0sR0FBR0EsVUFBVTtJQUMxQjtBQW9ORjtBQUVBLFdBQVc7QUFDSixNQUFNQyxZQUFZLElBQUk3RixZQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYWktc2VydmljZS50cz9mZGU5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRG9jdW1lbnRJbmZvIH0gZnJvbSAnbWRzaGFyZS1jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEFJVGFnU3VnZ2VzdGlvbiB7XG4gIHRhZzogc3RyaW5nXG4gIGNvbmZpZGVuY2U6IG51bWJlclxuICByZWFzb246IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvY3VtZW50QUlBbmFseXNpcyB7XG4gIGFpRnJpZW5kbGluZXNzU2NvcmU6IG51bWJlclxuICBzdWdnZXN0ZWRUYWdzOiBBSVRhZ1N1Z2dlc3Rpb25bXVxuICByZWxhdGlvbnNoaXBzOiBBcnJheTx7XG4gICAgdGFyZ2V0OiBzdHJpbmdcbiAgICByZWxhdGlvbnNoaXA6IHN0cmluZ1xuICAgIHN0cmVuZ3RoOiBudW1iZXJcbiAgfT5cbiAgaW1wcm92ZW1lbnRzOiBzdHJpbmdbXVxuICB0b3BpY3M6IHN0cmluZ1tdXG4gIHNlbnRpbWVudDogJ3Bvc2l0aXZlJyB8ICduZXV0cmFsJyB8ICduZWdhdGl2ZSdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBSVNlYXJjaFJlc3VsdCBleHRlbmRzIERvY3VtZW50SW5mbyB7XG4gIHJlbGV2YW5jZVNjb3JlOiBudW1iZXJcbiAgbWF0Y2hlZFRlcm1zOiBzdHJpbmdbXVxufVxuXG5leHBvcnQgY2xhc3MgQUlTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBhcGlLZXk6IHN0cmluZyB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IoYXBpS2V5Pzogc3RyaW5nKSB7XG4gICAgdGhpcy5hcGlLZXkgPSBhcGlLZXkgfHwgbnVsbFxuICB9XG5cbiAgLy8g7J6Q64+ZIO2DnOq3uCDsg53shLEgKE1vY2sg6rWs7ZiEKVxuICBhc3luYyBnZW5lcmF0ZVRhZ3MoY29udGVudDogc3RyaW5nLCB0aXRsZTogc3RyaW5nKTogUHJvbWlzZTxBSVRhZ1N1Z2dlc3Rpb25bXT4ge1xuICAgIC8vIOyLpOygnOuhnOuKlCBPcGVuQUkgQVBJ66W8IOyCrOyaqe2VmOyngOunjCwg7Jes6riw7ISc64qUIE1vY2sg6rWs7ZiEXG4gICAgY29uc3QgbW9ja1RhZ3M6IEFJVGFnU3VnZ2VzdGlvbltdID0gW11cblxuICAgIC8vIO2CpOybjOuTnCDquLDrsJgg7YOc6re4IOyDneyEsVxuICAgIGNvbnN0IGtleXdvcmRzID0gdGhpcy5leHRyYWN0S2V5d29yZHMoY29udGVudCArICcgJyArIHRpdGxlKVxuICAgIFxuICAgIGtleXdvcmRzLmZvckVhY2goa2V5d29yZCA9PiB7XG4gICAgICBjb25zdCBjb25maWRlbmNlID0gTWF0aC5yYW5kb20oKSAqIDAuNCArIDAuNiAvLyAwLjYtMS4wXG4gICAgICBtb2NrVGFncy5wdXNoKHtcbiAgICAgICAgdGFnOiBrZXl3b3JkLFxuICAgICAgICBjb25maWRlbmNlLFxuICAgICAgICByZWFzb246IGDrrLjshJzsl5DshJwgXCIke2tleXdvcmR9XCIg7YKk7JuM65Oc6rCAIOyekOyjvCDsgqzsmqnrkKhgXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICAvLyDsubTthYzqs6Drpqwg6riw67CYIO2DnOq3uCDsg53shLFcbiAgICBjb25zdCBjYXRlZ29yaWVzID0gdGhpcy5kZXRlY3RDYXRlZ29yaWVzKGNvbnRlbnQpXG4gICAgY2F0ZWdvcmllcy5mb3JFYWNoKGNhdGVnb3J5ID0+IHtcbiAgICAgIG1vY2tUYWdzLnB1c2goe1xuICAgICAgICB0YWc6IGNhdGVnb3J5LFxuICAgICAgICBjb25maWRlbmNlOiBNYXRoLnJhbmRvbSgpICogMC4zICsgMC43LFxuICAgICAgICByZWFzb246IGDrrLjshJwg64K07Jqp7J20IFwiJHtjYXRlZ29yeX1cIiDsubTthYzqs6Drpqzsl5Ag7ZW064u57ZWoYFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIG1vY2tUYWdzLnNvcnQoKGEsIGIpID0+IGIuY29uZmlkZW5jZSAtIGEuY29uZmlkZW5jZSlcbiAgfVxuXG4gIC8vIOydmOuvuOuhoOyggSDqsoDsg4kgKE1vY2sg6rWs7ZiEKVxuICBhc3luYyBzZW1hbnRpY1NlYXJjaChxdWVyeTogc3RyaW5nLCBkb2N1bWVudHM6IERvY3VtZW50SW5mb1tdKTogUHJvbWlzZTxBSVNlYXJjaFJlc3VsdFtdPiB7XG4gICAgY29uc3QgcmVzdWx0czogQUlTZWFyY2hSZXN1bHRbXSA9IFtdXG5cbiAgICBkb2N1bWVudHMuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgY29uc3QgcmVsZXZhbmNlU2NvcmUgPSB0aGlzLmNhbGN1bGF0ZVJlbGV2YW5jZShxdWVyeSwgZG9jKVxuICAgICAgaWYgKHJlbGV2YW5jZVNjb3JlID4gMC4xKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgLi4uZG9jLFxuICAgICAgICAgIHJlbGV2YW5jZVNjb3JlLFxuICAgICAgICAgIG1hdGNoZWRUZXJtczogdGhpcy5maW5kTWF0Y2hlZFRlcm1zKHF1ZXJ5LCBkb2MpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiByZXN1bHRzLnNvcnQoKGEsIGIpID0+IGIucmVsZXZhbmNlU2NvcmUgLSBhLnJlbGV2YW5jZVNjb3JlKVxuICB9XG5cbiAgLy8g66y47IScIOyalOyVvSDsg53shLFcbiAgYXN5bmMgZ2VuZXJhdGVTdW1tYXJ5KGNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgLy8gTW9jayDqtaztmIQgLSDsi6TsoJzroZzripQgQUkgQVBJIOyCrOyaqVxuICAgIGNvbnN0IHNlbnRlbmNlcyA9IGNvbnRlbnQuc3BsaXQoL1suIT9dKy8pLmZpbHRlcihzID0+IHMudHJpbSgpLmxlbmd0aCA+IDEwKVxuICAgIGNvbnN0IHN1bW1hcnkgPSBzZW50ZW5jZXMuc2xpY2UoMCwgMikuam9pbignLiAnKVxuICAgIHJldHVybiBzdW1tYXJ5ICsgKHNlbnRlbmNlcy5sZW5ndGggPiAyID8gJy4uLicgOiAnJylcbiAgfVxuXG4gIC8vIOusuOyEnCDqtIDqs4Qg67aE7ISdXG4gIGFzeW5jIGFuYWx5emVEb2N1bWVudFJlbGF0aW9uc2hpcHMoZG9jdW1lbnRzOiBEb2N1bWVudEluZm9bXSk6IFByb21pc2U8QXJyYXk8e1xuICAgIHNvdXJjZTogc3RyaW5nXG4gICAgdGFyZ2V0OiBzdHJpbmdcbiAgICByZWxhdGlvbnNoaXA6IHN0cmluZ1xuICAgIHN0cmVuZ3RoOiBudW1iZXJcbiAgfT4+IHtcbiAgICBjb25zdCByZWxhdGlvbnNoaXBzOiBBcnJheTx7XG4gICAgICBzb3VyY2U6IHN0cmluZ1xuICAgICAgdGFyZ2V0OiBzdHJpbmdcbiAgICAgIHJlbGF0aW9uc2hpcDogc3RyaW5nXG4gICAgICBzdHJlbmd0aDogbnVtYmVyXG4gICAgfT4gPSBbXVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb2N1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGRvY3VtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBkb2MxID0gZG9jdW1lbnRzW2ldXG4gICAgICAgIGNvbnN0IGRvYzIgPSBkb2N1bWVudHNbal1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSB0aGlzLmNhbGN1bGF0ZVNpbWlsYXJpdHkoZG9jMSwgZG9jMilcbiAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiAwLjMpIHtcbiAgICAgICAgICByZWxhdGlvbnNoaXBzLnB1c2goe1xuICAgICAgICAgICAgc291cmNlOiBkb2MxLnRpdGxlLFxuICAgICAgICAgICAgdGFyZ2V0OiBkb2MyLnRpdGxlLFxuICAgICAgICAgICAgcmVsYXRpb25zaGlwOiB0aGlzLmRldGVybWluZVJlbGF0aW9uc2hpcChkb2MxLCBkb2MyKSxcbiAgICAgICAgICAgIHN0cmVuZ3RoOiBzaW1pbGFyaXR5XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZWxhdGlvbnNoaXBzXG4gIH1cblxuICAvLyDtgqTsm4zrk5wg7LaU7LacIChNb2NrKVxuICBwcml2YXRlIGV4dHJhY3RLZXl3b3Jkcyh0ZXh0OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3Qgd29yZHMgPSB0ZXh0LnRvTG93ZXJDYXNlKClcbiAgICAgIC5yZXBsYWNlKC9bXlxcd1xcc+qwgC3tnqNdL2csICcgJylcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAuZmlsdGVyKHdvcmQgPT4gd29yZC5sZW5ndGggPiAyKVxuXG4gICAgY29uc3Qgd29yZENvdW50ID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKVxuICAgIHdvcmRzLmZvckVhY2god29yZCA9PiB7XG4gICAgICB3b3JkQ291bnQuc2V0KHdvcmQsICh3b3JkQ291bnQuZ2V0KHdvcmQpIHx8IDApICsgMSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIEFycmF5LmZyb20od29yZENvdW50LmVudHJpZXMoKSlcbiAgICAgIC5maWx0ZXIoKFtfLCBjb3VudF0pID0+IGNvdW50ID4gMSlcbiAgICAgIC5zb3J0KChbLCBhXSwgWywgYl0pID0+IGIgLSBhKVxuICAgICAgLnNsaWNlKDAsIDUpXG4gICAgICAubWFwKChbd29yZCwgX10pID0+IHdvcmQpXG4gIH1cblxuICAvLyDsubTthYzqs6Drpqwg6rCQ7KeAIChNb2NrKVxuICBwcml2YXRlIGRldGVjdENhdGVnb3JpZXMoY29udGVudDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGNhdGVnb3JpZXM6IHN0cmluZ1tdID0gW11cbiAgICBjb25zdCB0ZXh0ID0gY29udGVudC50b0xvd2VyQ2FzZSgpXG5cbiAgICBpZiAodGV4dC5pbmNsdWRlcygnYXBpJykgfHwgdGV4dC5pbmNsdWRlcygnZW5kcG9pbnQnKSB8fCB0ZXh0LmluY2x1ZGVzKCdyZXN0JykpIHtcbiAgICAgIGNhdGVnb3JpZXMucHVzaCgnQVBJJylcbiAgICB9XG4gICAgaWYgKHRleHQuaW5jbHVkZXMoJ+yEpOy5mCcpIHx8IHRleHQuaW5jbHVkZXMoJ3NldHVwJykgfHwgdGV4dC5pbmNsdWRlcygn7ZmY6rK9JykpIHtcbiAgICAgIGNhdGVnb3JpZXMucHVzaCgn7ISk7LmYJylcbiAgICB9XG4gICAgaWYgKHRleHQuaW5jbHVkZXMoJ+usuOyEnCcpIHx8IHRleHQuaW5jbHVkZXMoJ2RvY3VtZW50YXRpb24nKSB8fCB0ZXh0LmluY2x1ZGVzKCfqsIDsnbTrk5wnKSkge1xuICAgICAgY2F0ZWdvcmllcy5wdXNoKCfrrLjshJwnKVxuICAgIH1cbiAgICBpZiAodGV4dC5pbmNsdWRlcygn7ZSE66Gc7KCd7Yq4JykgfHwgdGV4dC5pbmNsdWRlcygncHJvamVjdCcpIHx8IHRleHQuaW5jbHVkZXMoJ+qwnOyalCcpKSB7XG4gICAgICBjYXRlZ29yaWVzLnB1c2goJ+2UhOuhnOygne2KuCcpXG4gICAgfVxuICAgIGlmICh0ZXh0LmluY2x1ZGVzKCfqsJzrsJwnKSB8fCB0ZXh0LmluY2x1ZGVzKCdkZXZlbG9wbWVudCcpIHx8IHRleHQuaW5jbHVkZXMoJ+y9lOuTnCcpKSB7XG4gICAgICBjYXRlZ29yaWVzLnB1c2goJ+qwnOuwnCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNhdGVnb3JpZXNcbiAgfVxuXG4gIC8vIOq0gOugqOyEsSDqs4TsgrAgKE1vY2spXG4gIHByaXZhdGUgY2FsY3VsYXRlUmVsZXZhbmNlKHF1ZXJ5OiBzdHJpbmcsIGRvYzogRG9jdW1lbnRJbmZvKTogbnVtYmVyIHtcbiAgICBjb25zdCBxdWVyeVRlcm1zID0gcXVlcnkudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy8pXG4gICAgbGV0IHNjb3JlID0gMFxuXG4gICAgLy8g7KCc66qpIOunpOy5rSAo64aS7J2AIOqwgOykkey5mClcbiAgICBxdWVyeVRlcm1zLmZvckVhY2godGVybSA9PiB7XG4gICAgICBpZiAoZG9jLnRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGVybSkpIHtcbiAgICAgICAgc2NvcmUgKz0gMC40XG4gICAgICB9XG4gICAgICBpZiAoZG9jLmRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGVybSkpIHtcbiAgICAgICAgc2NvcmUgKz0gMC4yXG4gICAgICB9XG4gICAgICBpZiAoZG9jLnRhZ3Muc29tZSh0YWcgPT4gdGFnLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGVybSkpKSB7XG4gICAgICAgIHNjb3JlICs9IDAuM1xuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gTWF0aC5taW4oc2NvcmUsIDEuMClcbiAgfVxuXG4gIC8vIOunpOy5reuQnCDsmqnslrQg7LC+6riwXG4gIHByaXZhdGUgZmluZE1hdGNoZWRUZXJtcyhxdWVyeTogc3RyaW5nLCBkb2M6IERvY3VtZW50SW5mbyk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBxdWVyeVRlcm1zID0gcXVlcnkudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy8pXG4gICAgY29uc3QgbWF0Y2hlZFRlcm1zOiBzdHJpbmdbXSA9IFtdXG5cbiAgICBxdWVyeVRlcm1zLmZvckVhY2godGVybSA9PiB7XG4gICAgICBpZiAoZG9jLnRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGVybSkgfHxcbiAgICAgICAgICBkb2MuZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXJtKSB8fFxuICAgICAgICAgIGRvYy50YWdzLnNvbWUodGFnID0+IHRhZy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRlcm0pKSkge1xuICAgICAgICBtYXRjaGVkVGVybXMucHVzaCh0ZXJtKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gbWF0Y2hlZFRlcm1zXG4gIH1cblxuICAvLyDrrLjshJwg7Jyg7IKs64+EIOqzhOyCsFxuICBwcml2YXRlIGNhbGN1bGF0ZVNpbWlsYXJpdHkoZG9jMTogRG9jdW1lbnRJbmZvLCBkb2MyOiBEb2N1bWVudEluZm8pOiBudW1iZXIge1xuICAgIC8vIO2DnOq3uCDsnKDsgqzrj4RcbiAgICBjb25zdCB0YWdzMSA9IG5ldyBTZXQoZG9jMS50YWdzKVxuICAgIGNvbnN0IHRhZ3MyID0gbmV3IFNldChkb2MyLnRhZ3MpXG4gICAgY29uc3QgY29tbW9uVGFncyA9IG5ldyBTZXQoWy4uLnRhZ3MxXS5maWx0ZXIodGFnID0+IHRhZ3MyLmhhcyh0YWcpKSlcbiAgICBjb25zdCB0YWdTaW1pbGFyaXR5ID0gY29tbW9uVGFncy5zaXplIC8gTWF0aC5tYXgodGFnczEuc2l6ZSwgdGFnczIuc2l6ZSlcblxuICAgIC8vIOygnOuqqSDsnKDsgqzrj4QgKOqwhOuLqO2VnCDrrLjsnpDsl7Qg7Jyg7IKs64+EKVxuICAgIGNvbnN0IHRpdGxlU2ltaWxhcml0eSA9IHRoaXMuc3RyaW5nU2ltaWxhcml0eShkb2MxLnRpdGxlLCBkb2MyLnRpdGxlKVxuXG4gICAgcmV0dXJuICh0YWdTaW1pbGFyaXR5ICogMC42ICsgdGl0bGVTaW1pbGFyaXR5ICogMC40KVxuICB9XG5cbiAgLy8g66y47J6Q7Je0IOycoOyCrOuPhCDqs4TsgrAgKOqwhOuLqO2VnCDqtaztmIQpXG4gIHByaXZhdGUgc3RyaW5nU2ltaWxhcml0eShzdHIxOiBzdHJpbmcsIHN0cjI6IHN0cmluZyk6IG51bWJlciB7XG4gICAgY29uc3Qgd29yZHMxID0gc3RyMS50b0xvd2VyQ2FzZSgpLnNwbGl0KC9cXHMrLylcbiAgICBjb25zdCB3b3JkczIgPSBzdHIyLnRvTG93ZXJDYXNlKCkuc3BsaXQoL1xccysvKVxuICAgIGNvbnN0IGNvbW1vbldvcmRzID0gd29yZHMxLmZpbHRlcih3b3JkID0+IHdvcmRzMi5pbmNsdWRlcyh3b3JkKSlcbiAgICByZXR1cm4gY29tbW9uV29yZHMubGVuZ3RoIC8gTWF0aC5tYXgod29yZHMxLmxlbmd0aCwgd29yZHMyLmxlbmd0aClcbiAgfVxuXG4gIC8vIOq0gOqzhCDsnKDtmJUg6rKw7KCVXG4gIHByaXZhdGUgZGV0ZXJtaW5lUmVsYXRpb25zaGlwKGRvYzE6IERvY3VtZW50SW5mbywgZG9jMjogRG9jdW1lbnRJbmZvKTogc3RyaW5nIHtcbiAgICBjb25zdCB0YWdzMSA9IG5ldyBTZXQoZG9jMS50YWdzKVxuICAgIGNvbnN0IHRhZ3MyID0gbmV3IFNldChkb2MyLnRhZ3MpXG4gICAgY29uc3QgY29tbW9uVGFncyA9IFsuLi50YWdzMV0uZmlsdGVyKHRhZyA9PiB0YWdzMi5oYXModGFnKSlcblxuICAgIGlmIChjb21tb25UYWdzLmluY2x1ZGVzKCdBUEknKSAmJiBjb21tb25UYWdzLmluY2x1ZGVzKCfrrLjshJwnKSkge1xuICAgICAgcmV0dXJuICdBUEkg66y47IScIOq0gOqzhCdcbiAgICB9XG4gICAgaWYgKGNvbW1vblRhZ3MuaW5jbHVkZXMoJ+yEpOy5mCcpICYmIGNvbW1vblRhZ3MuaW5jbHVkZXMoJ+qwnOuwnCcpKSB7XG4gICAgICByZXR1cm4gJ+qwnOuwnCDtmZjqsr0g6rSA6rOEJ1xuICAgIH1cbiAgICBpZiAoY29tbW9uVGFncy5pbmNsdWRlcygn7ZSE66Gc7KCd7Yq4JykgJiYgY29tbW9uVGFncy5pbmNsdWRlcygn66y47IScJykpIHtcbiAgICAgIHJldHVybiAn7ZSE66Gc7KCd7Yq4IOusuOyEnCDqtIDqs4QnXG4gICAgfVxuXG4gICAgcmV0dXJuICfqtIDroKgg66y47IScJ1xuICB9XG59XG5cbi8vIOyLseq4gO2GpCDsnbjsiqTthLTsiqRcbmV4cG9ydCBjb25zdCBhaVNlcnZpY2UgPSBuZXcgQUlTZXJ2aWNlKClcbiJdLCJuYW1lcyI6WyJBSVNlcnZpY2UiLCJnZW5lcmF0ZVRhZ3MiLCJjb250ZW50IiwidGl0bGUiLCJtb2NrVGFncyIsImtleXdvcmRzIiwiZXh0cmFjdEtleXdvcmRzIiwiZm9yRWFjaCIsImtleXdvcmQiLCJjb25maWRlbmNlIiwiTWF0aCIsInJhbmRvbSIsInB1c2giLCJ0YWciLCJyZWFzb24iLCJjYXRlZ29yaWVzIiwiZGV0ZWN0Q2F0ZWdvcmllcyIsImNhdGVnb3J5Iiwic29ydCIsImEiLCJiIiwic2VtYW50aWNTZWFyY2giLCJxdWVyeSIsImRvY3VtZW50cyIsInJlc3VsdHMiLCJkb2MiLCJyZWxldmFuY2VTY29yZSIsImNhbGN1bGF0ZVJlbGV2YW5jZSIsIm1hdGNoZWRUZXJtcyIsImZpbmRNYXRjaGVkVGVybXMiLCJnZW5lcmF0ZVN1bW1hcnkiLCJzZW50ZW5jZXMiLCJzcGxpdCIsImZpbHRlciIsInMiLCJ0cmltIiwibGVuZ3RoIiwic3VtbWFyeSIsInNsaWNlIiwiam9pbiIsImFuYWx5emVEb2N1bWVudFJlbGF0aW9uc2hpcHMiLCJyZWxhdGlvbnNoaXBzIiwiaSIsImoiLCJkb2MxIiwiZG9jMiIsInNpbWlsYXJpdHkiLCJjYWxjdWxhdGVTaW1pbGFyaXR5Iiwic291cmNlIiwidGFyZ2V0IiwicmVsYXRpb25zaGlwIiwiZGV0ZXJtaW5lUmVsYXRpb25zaGlwIiwic3RyZW5ndGgiLCJ0ZXh0Iiwid29yZHMiLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJ3b3JkIiwid29yZENvdW50IiwiTWFwIiwic2V0IiwiZ2V0IiwiQXJyYXkiLCJmcm9tIiwiZW50cmllcyIsIl8iLCJjb3VudCIsIm1hcCIsImluY2x1ZGVzIiwicXVlcnlUZXJtcyIsInNjb3JlIiwidGVybSIsImRlc2NyaXB0aW9uIiwidGFncyIsInNvbWUiLCJtaW4iLCJ0YWdzMSIsIlNldCIsInRhZ3MyIiwiY29tbW9uVGFncyIsImhhcyIsInRhZ1NpbWlsYXJpdHkiLCJzaXplIiwibWF4IiwidGl0bGVTaW1pbGFyaXR5Iiwic3RyaW5nU2ltaWxhcml0eSIsInN0cjEiLCJzdHIyIiwid29yZHMxIiwid29yZHMyIiwiY29tbW9uV29yZHMiLCJjb25zdHJ1Y3RvciIsImFwaUtleSIsImFpU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/ai-service.ts\n"));

/***/ })

});
# ê¸°ìˆ  ì•„í‚¤í…ì²˜ ë° ìƒì„¸ ê¸°ëŠ¥ ëª…ì„¸

## ğŸ—ï¸ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### ì „ì²´ êµ¬ì¡°
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Desktop App    â”‚ â† ë¡œì»¬ ì—…ë¡œë“œ ì „ìš©
â”‚  (Electron)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ HTTPS
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           API Gateway                    â”‚
â”‚         (Rate Limiting)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â–¼            â–¼          â–¼          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ Upload â”‚  â”‚ Auth   â”‚  â”‚ View â”‚  â”‚ AI   â”‚
â”‚Service â”‚  â”‚Service â”‚  â”‚Serviceâ”‚ â”‚Serviceâ”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”¬â”€â”€â”€â”˜
    â”‚           â”‚          â”‚         â”‚
    â–¼           â–¼          â–¼         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         PostgreSQL                        â”‚
â”‚  (Users, Projects, Files, Permissions)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚           â”‚          â”‚         â”‚
    â–¼           â–¼          â–¼         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   S3    â”‚ â”‚ Redis  â”‚ â”‚ CDN  â”‚ â”‚ Pinecone â”‚
â”‚(Files)  â”‚ â”‚(Cache) â”‚ â”‚(é™çš„)â”‚ â”‚(Vector)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”„ í•˜ì´ë¸Œë¦¬ë“œ ì•„í‚¤í…ì²˜ (Markdown â†” JSON) â­ í•µì‹¬ ì°¨ë³„í™”

### ì² í•™: "ì‚¬ìš©ìëŠ” ë‹¨ìˆœí•˜ê²Œ, AIëŠ” ë˜‘ë˜‘í•˜ê²Œ"

**í•µì‹¬ ê°œë…:**
- **ì‚¬ìš©ì ë ˆì´ì–´**: Markdown íŒŒì¼ (ê°„ë‹¨, Git í˜¸í™˜, ë°ì´í„° ì†Œìœ ê¶Œ)
- **AI ë ˆì´ì–´**: JSON êµ¬ì¡°í™” (ê²€ìƒ‰, ì¸ë±ì‹±, ë²¡í„°í™”, ê´€ê³„ ë¶„ì„)
- **Best of Both Worlds**: GitBookì˜ ë‹¨ìˆœí•¨ + Notionì˜ ë˜‘ë˜‘í•¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 1: ì‚¬ìš©ì ì†ŒìŠ¤ (Source of Truth)        â”‚
â”‚  .md íŒŒì¼ â†’ Git ë²„ì „ ê´€ë¦¬ â†’ ì‚¬ìš©ì ì§ì ‘ í¸ì§‘      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ Parsing Pipeline
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 2: êµ¬ì¡°í™” ë ˆì´ì–´ (JSON)                  â”‚
â”‚  AST â†’ Block ë¶„í•´ â†’ ë©”íƒ€ë°ì´í„° ì¶”ì¶œ â†’ ê´€ê³„ ë¶„ì„   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ AI Processing
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 3: AI ë ˆì´ì–´                           â”‚
â”‚  ë²¡í„°í™” â†’ ê²€ìƒ‰ ì¸ë±ìŠ¤ â†’ ìë™ íƒœê¹… â†’ ê´€ê³„ ê·¸ë˜í”„    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Markdown â†’ JSON ë³€í™˜ íŒŒì´í”„ë¼ì¸

#### 1. íŒŒì‹± & êµ¬ì¡°í™”
```typescript
// lib/parser/markdown-to-json.ts

interface ParsedDocument {
  id: string;
  metadata: DocumentMetadata;
  blocks: Block[];
  structure: DocumentStructure;
  aiEnriched: AIEnrichment;
}

interface Block {
  id: string;
  type: 'heading' | 'paragraph' | 'list' | 'code' | 'table' | 'image';
  level?: number;        // headingë§Œ í•´ë‹¹
  content: string;
  rawMarkdown: string;
  position: { start: number; end: number };
  vector?: number[];     // AI ë²¡í„° ì„ë² ë”©
  children?: Block[];    // ê³„ì¸µ êµ¬ì¡°
}

interface DocumentMetadata {
  // Frontmatter ì¶”ì¶œ
  title: string;
  date?: string;
  author?: string;
  tags?: string[];
  category?: string;

  // AI ìë™ ì¶”ì¶œ
  summary?: string;              // AI ìƒì„± ìš”ì•½
  relatedDocs?: string[];        // AI ë°œê²¬ ê´€ë ¨ ë¬¸ì„œ
  prerequisites?: string[];      // ì„ í–‰ ë¬¸ì„œ
  targetAudience?: string[];     // ëŒ€ìƒ ë…ì
  estimatedReadingTime?: number; // ì˜ˆìƒ ì½ê¸° ì‹œê°„

  // ê³„ì¸µ êµ¬ì¡°
  parent?: string;
  children?: string[];

  // AI ì¹œí™”ë„
  aiScore?: number;              // 0-100
  aiSuggestions?: string[];      // ê°œì„  ì œì•ˆ
}

// ì „ì²´ íŒŒì‹± í”„ë¡œì„¸ìŠ¤
async function parseMarkdownToJSON(
  markdownContent: string,
  filePath: string,
  projectId: string
): Promise<ParsedDocument> {

  // 1. Frontmatter ì¶”ì¶œ
  const { frontmatter, content } = extractFrontmatter(markdownContent);

  // 2. Markdown â†’ AST (Abstract Syntax Tree)
  const ast = unified()
    .use(remarkParse)
    .use(remarkGfm)
    .parse(content);

  // 3. AST â†’ Block êµ¬ì¡°
  const blocks: Block[] = [];
  let blockId = 0;

  visit(ast, (node) => {
    if (isBlockNode(node)) {
      blocks.push({
        id: `${projectId}_${filePath}_${blockId++}`,
        type: node.type as Block['type'],
        level: node.depth,
        content: extractTextContent(node),
        rawMarkdown: nodeToMarkdown(node),
        position: node.position,
        children: node.children ? parseChildren(node.children) : []
      });
    }
  });

  // 4. ë¬¸ì„œ êµ¬ì¡° ë¶„ì„
  const structure = analyzeDocumentStructure(blocks);

  // 5. AI ë¶„ì„ (ë¹„ë™ê¸° íë¡œ ì²˜ë¦¬)
  const aiEnriched = await enrichWithAI(blocks, frontmatter);

  return {
    id: generateDocId(projectId, filePath),
    metadata: {
      ...frontmatter,
      ...aiEnriched.metadata
    },
    blocks,
    structure,
    aiEnriched
  };
}
```

#### 2. ë¬¸ì„œ êµ¬ì¡° ë¶„ì„
```typescript
interface DocumentStructure {
  headings: HeadingNode[];
  tableOfContents: TOCEntry[];
  sections: Section[];
  links: Link[];
  codeBlocks: CodeBlock[];
  images: Image[];
}

interface HeadingNode {
  id: string;
  level: number;
  text: string;
  children: HeadingNode[];
  blockIds: string[];  // ì´ ì„¹ì…˜ì— ì†í•œ ë¸”ë¡ë“¤
}

// ìë™ ëª©ì°¨ ìƒì„±
function generateTableOfContents(blocks: Block[]): TOCEntry[] {
  const toc: TOCEntry[] = [];
  const headings = blocks.filter(b => b.type === 'heading');

  let stack: { level: number; entry: TOCEntry }[] = [];

  for (const heading of headings) {
    const entry: TOCEntry = {
      id: heading.id,
      level: heading.level,
      text: heading.content,
      children: []
    };

    // ê³„ì¸µ êµ¬ì¡° ìƒì„±
    while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
      stack.pop();
    }

    if (stack.length === 0) {
      toc.push(entry);
    } else {
      stack[stack.length - 1].entry.children.push(entry);
    }

    stack.push({ level: heading.level, entry });
  }

  return toc;
}
```

#### 3. AI ìë™ ë¶„ì„ & ê°•í™”
```typescript
// AI ë¶„ì„ íŒŒì´í”„ë¼ì¸ (BullMQ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…)
async function enrichWithAI(
  blocks: Block[],
  frontmatter: DocumentMetadata
): Promise<AIEnrichment> {

  // 1. ë¬¸ì„œ ìš”ì•½ ìƒì„± (frontmatter.summaryê°€ ì—†ì„ ë•Œë§Œ)
  let summary = frontmatter.summary;
  if (!summary) {
    summary = await generateSummary(blocks);
  }

  // 2. ìë™ íƒœê¹… (frontmatter.tags ë³´ì™„)
  const autoTags = await extractTags(blocks);
  const tags = [...new Set([...(frontmatter.tags || []), ...autoTags])];

  // 3. ë¸”ë¡ ë‹¨ìœ„ ë²¡í„°í™”
  const blocksWithVectors = await Promise.all(
    blocks.map(async (block) => ({
      ...block,
      vector: await embedText(block.content)
    }))
  );

  // 4. AI ì¹œí™”ë„ í‰ê°€
  const aiScore = evaluateAIFriendliness({
    frontmatter,
    blocks,
    structure: analyzeDocumentStructure(blocks)
  });

  // 5. ê°œì„  ì œì•ˆ ìƒì„±
  const suggestions = generateImprovementSuggestions(aiScore);

  return {
    metadata: {
      summary,
      tags,
      aiScore: aiScore.total,
      aiSuggestions: suggestions
    },
    blocksWithVectors
  };
}

// AI ì¹œí™”ë„ í‰ê°€ ì•Œê³ ë¦¬ì¦˜
function evaluateAIFriendliness(doc: {
  frontmatter: DocumentMetadata;
  blocks: Block[];
  structure: DocumentStructure;
}): AIScore {

  let scores = {
    frontmatter: 0,   // 30ì 
    structure: 0,     // 30ì 
    clarity: 0,       // 20ì 
    links: 0          // 20ì 
  };

  // 1. Frontmatter ì™„ì„±ë„ (30ì )
  const requiredFields = ['title', 'summary', 'tags', 'category'];
  const optionalFields = ['relatedDocs', 'prerequisites', 'targetAudience'];

  scores.frontmatter += requiredFields.filter(f => doc.frontmatter[f]).length * 5;
  scores.frontmatter += optionalFields.filter(f => doc.frontmatter[f]).length * 3;

  // 2. êµ¬ì¡°í™” ìˆ˜ì¤€ (30ì )
  const hasHeadings = doc.structure.headings.length > 0;
  const hasMultipleLevels = new Set(doc.structure.headings.map(h => h.level)).size > 1;
  const hasCodeBlocks = doc.structure.codeBlocks.length > 0;
  const hasTOC = doc.structure.tableOfContents.length >= 3;

  if (hasHeadings) scores.structure += 10;
  if (hasMultipleLevels) scores.structure += 10;
  if (hasCodeBlocks) scores.structure += 5;
  if (hasTOC) scores.structure += 5;

  // 3. ë‚´ìš© ëª…í™•ì„± (20ì )
  const avgBlockLength = doc.blocks.reduce((sum, b) => sum + b.content.length, 0) / doc.blocks.length;
  const hasLists = doc.blocks.some(b => b.type === 'list');
  const hasExamples = doc.blocks.some(b => b.content.includes('ì˜ˆ:') || b.content.includes('example'));

  if (avgBlockLength > 50 && avgBlockLength < 500) scores.clarity += 10; // ì ì • ê¸¸ì´
  if (hasLists) scores.clarity += 5;
  if (hasExamples) scores.clarity += 5;

  // 4. ë§í¬ ë° ê´€ê³„ (20ì )
  const internalLinks = doc.structure.links.filter(l => l.type === 'internal').length;
  const hasRelatedDocs = doc.frontmatter.relatedDocs && doc.frontmatter.relatedDocs.length > 0;

  scores.links += Math.min(internalLinks * 3, 15);
  if (hasRelatedDocs) scores.links += 5;

  const total = Object.values(scores).reduce((sum, s) => sum + s, 0);

  return {
    ...scores,
    total,
    grade: total >= 80 ? 'excellent' : total >= 60 ? 'good' : total >= 40 ? 'fair' : 'poor'
  };
}
```

### JSON ê¸°ë°˜ ê²€ìƒ‰ ìµœì í™”

#### 1. í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ (Lexical + Semantic)
```typescript
// ê²€ìƒ‰ ì „ëµ: í‚¤ì›Œë“œ + ì˜ë¯¸ ê¸°ë°˜ ê²°í•©
async function hybridSearch(
  projectId: string,
  query: string,
  options: SearchOptions = {}
): Promise<SearchResult[]> {

  // 1. Lexical Search (BM25 ì•Œê³ ë¦¬ì¦˜ - Elasticsearch)
  const lexicalResults = await elasticsearch.search({
    index: `project_${projectId}`,
    body: {
      query: {
        multi_match: {
          query,
          fields: ['metadata.title^3', 'blocks.content^2', 'metadata.tags'],
          type: 'best_fields',
          fuzziness: 'AUTO'
        }
      },
      size: 20
    }
  });

  // 2. Semantic Search (ë²¡í„° ìœ ì‚¬ë„ - Pinecone)
  const queryEmbedding = await embedText(query);
  const semanticResults = await pinecone.query({
    vector: queryEmbedding,
    topK: 20,
    filter: { projectId },
    includeMetadata: true
  });

  // 3. Hybrid Fusion (Reciprocal Rank Fusion)
  const combined = fuseResults(lexicalResults, semanticResults);

  // 4. Metadata Filtering
  const filtered = applyMetadataFilters(combined, options);

  // 5. Reranking (Cross-Encoder for top 10)
  const reranked = await rerankResults(query, filtered.slice(0, 10));

  return reranked;
}

// Reciprocal Rank Fusion ì•Œê³ ë¦¬ì¦˜
function fuseResults(
  lexicalResults: any[],
  semanticResults: any[],
  k: number = 60
): SearchResult[] {
  const scores = new Map<string, number>();

  // Lexical ì ìˆ˜
  lexicalResults.forEach((result, rank) => {
    const docId = result._id;
    scores.set(docId, (scores.get(docId) || 0) + 1 / (k + rank + 1));
  });

  // Semantic ì ìˆ˜
  semanticResults.forEach((result, rank) => {
    const docId = result.id;
    scores.set(docId, (scores.get(docId) || 0) + 1 / (k + rank + 1));
  });

  // ì ìˆ˜ìˆœ ì •ë ¬
  return Array.from(scores.entries())
    .sort((a, b) => b[1] - a[1])
    .map(([docId, score]) => ({
      docId,
      score,
      // ... ë©”íƒ€ë°ì´í„°
    }));
}
```

#### 2. ê³„ì¸µì  ê²€ìƒ‰ (Hierarchical Search)
```typescript
// 3ë‹¨ê³„ ê²€ìƒ‰: ë¬¸ì„œ â†’ ì„¹ì…˜ â†’ ë¸”ë¡
async function hierarchicalSearch(
  projectId: string,
  query: string
): Promise<HierarchicalResult[]> {

  // Level 1: ë¬¸ì„œ ë ˆë²¨ ê²€ìƒ‰
  const relevantDocs = await searchDocuments(projectId, query, { topK: 5 });

  // Level 2: ê´€ë ¨ ë¬¸ì„œ ë‚´ ì„¹ì…˜ ê²€ìƒ‰
  const sections = await Promise.all(
    relevantDocs.map(doc =>
      searchSectionsInDoc(doc.id, query)
    )
  );

  // Level 3: ë¸”ë¡ ë‹¨ìœ„ ì •ë°€ ê²€ìƒ‰
  const blocks = await Promise.all(
    sections.flat().map(section =>
      searchBlocksInSection(section.id, query)
    )
  );

  return {
    documents: relevantDocs,
    sections: sections.flat(),
    blocks: blocks.flat()
  };
}
```

#### 3. ì¿¼ë¦¬ í™•ì¥ (Query Expansion)
```typescript
// LLMìœ¼ë¡œ ë™ì˜ì–´/ì•½ì–´ í™•ì¥
async function expandQuery(query: string): Promise<string[]> {
  const expanded = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [{
      role: 'system',
      content: 'ì‚¬ìš©ì ê²€ìƒ‰ì–´ì˜ ë™ì˜ì–´, ì•½ì–´, ê´€ë ¨ ìš©ì–´ë¥¼ 5ê°œ ì´ë‚´ë¡œ ì¶”ì¶œí•˜ì„¸ìš”.'
    }, {
      role: 'user',
      content: query
    }],
    temperature: 0.3
  });

  return [query, ...parseExpandedTerms(expanded.choices[0].message.content)];
}

// ì˜ˆì‹œ:
// "JWT" â†’ ["JWT", "JSON Web Token", "í† í° ì¸ì¦", "Bearer Token"]
// "ì˜¨ë³´ë”©" â†’ ["ì˜¨ë³´ë”©", "ì‹ ì…êµìœ¡", "ì‹ ê·œì…ì‚¬", "ì˜¤ë¦¬ì—”í…Œì´ì…˜"]
```

### ìë™ ì¸ë±ì‹± ì‹œìŠ¤í…œ

#### 1. ì¸ë±ìŠ¤ ìë™ ìƒì„±
```typescript
// .index/ í´ë” ìë™ ìƒì„±
async function generateAutoIndexes(projectId: string) {
  const allDocs = await getAllDocuments(projectId);

  // 1. ì£¼ì œë³„ ì¸ë±ìŠ¤ (AI ìë™ ë¶„ë¥˜)
  const byTopic = await clusterByTopic(allDocs);
  await saveIndex(projectId, 'by-topic.md', formatTopicIndex(byTopic));

  // 2. ë‚ ì§œë³„ íƒ€ì„ë¼ì¸
  const byDate = groupByDate(allDocs);
  await saveIndex(projectId, 'by-date.md', formatDateIndex(byDate));

  // 3. ì‘ì„±ìë³„
  const byAuthor = groupByAuthor(allDocs);
  await saveIndex(projectId, 'by-author.md', formatAuthorIndex(byAuthor));

  // 4. ì¹´í…Œê³ ë¦¬ë³„ (frontmatter ê¸°ë°˜)
  const byCategory = groupByCategory(allDocs);
  await saveIndex(projectId, 'by-category.md', formatCategoryIndex(byCategory));

  // 5. ë¬¸ì„œ ê´€ê³„ ê·¸ë˜í”„
  const relationships = await analyzeDocumentRelationships(allDocs);
  await saveIndex(projectId, 'related-docs.md', formatRelationshipIndex(relationships));

  // 6. AI ì¶”ì²œ êµ¬ì¡°
  const aiSuggested = await generateRecommendedStructure(allDocs);
  await saveIndex(projectId, 'ai-suggested.md', formatSuggestedIndex(aiSuggested));
}

// AI ê¸°ë°˜ ì£¼ì œ í´ëŸ¬ìŠ¤í„°ë§
async function clusterByTopic(docs: ParsedDocument[]): Promise<TopicCluster[]> {
  // 1. ëª¨ë“  ë¬¸ì„œ ë²¡í„° ìˆ˜ì§‘
  const vectors = docs.map(doc => ({
    id: doc.id,
    vector: averageBlockVectors(doc.blocks),
    title: doc.metadata.title
  }));

  // 2. K-means í´ëŸ¬ìŠ¤í„°ë§ (ë˜ëŠ” HDBSCAN)
  const clusters = performClustering(vectors, { k: 'auto' });

  // 3. ê° í´ëŸ¬ìŠ¤í„° ì£¼ì œ ë ˆì´ë¸”ë§ (LLM)
  const labeled = await Promise.all(
    clusters.map(async (cluster) => {
      const docTitles = cluster.members.map(m => m.title);
      const label = await generateTopicLabel(docTitles);
      return { ...cluster, topic: label };
    })
  );

  return labeled;
}

// ë¬¸ì„œ ê´€ê³„ ë¶„ì„ (ë²¡í„° ìœ ì‚¬ë„ + ë§í¬ ê·¸ë˜í”„)
async function analyzeDocumentRelationships(
  docs: ParsedDocument[]
): Promise<DocumentRelationship[]> {
  const relationships: DocumentRelationship[] = [];

  for (const doc of docs) {
    // 1. ëª…ì‹œì  ë§í¬ (ë‚´ë¶€ ë§í¬)
    const explicitLinks = doc.structure.links
      .filter(l => l.type === 'internal')
      .map(l => ({ target: l.href, strength: 1.0, type: 'explicit' }));

    // 2. ì•”ì‹œì  ê´€ê³„ (ë²¡í„° ìœ ì‚¬ë„)
    const docVector = averageBlockVectors(doc.blocks);
    const similar = await findSimilarDocuments(docVector, docs, { topK: 5, threshold: 0.7 });
    const implicitLinks = similar.map(s => ({
      target: s.id,
      strength: s.similarity,
      type: 'semantic'
    }));

    // 3. ê³„ì¸µì  ê´€ê³„ (frontmatter parent/children)
    const hierarchical = [
      ...(doc.metadata.parent ? [{ target: doc.metadata.parent, type: 'parent' }] : []),
      ...(doc.metadata.children || []).map(c => ({ target: c, type: 'child' }))
    ];

    relationships.push({
      source: doc.id,
      links: [...explicitLinks, ...implicitLinks, ...hierarchical]
    });
  }

  return relationships;
}
```

#### 2. ì‹¤ì‹œê°„ ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸
```typescript
// ë¬¸ì„œ ì¶”ê°€/ìˆ˜ì • ì‹œ ìë™ ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸
async function onDocumentChange(
  projectId: string,
  docId: string,
  changeType: 'create' | 'update' | 'delete'
) {
  // 1. ì˜í–¥ë°›ëŠ” ì¸ë±ìŠ¤ ì‹ë³„
  const affectedIndexes = identifyAffectedIndexes(docId, changeType);

  // 2. ì¦ë¶„ ì—…ë°ì´íŠ¸ (ì „ì²´ ì¬ìƒì„± ì•„ë‹˜)
  for (const indexType of affectedIndexes) {
    await updateIndexIncremental(projectId, indexType, docId, changeType);
  }

  // 3. ê´€ê³„ ê·¸ë˜í”„ ì—…ë°ì´íŠ¸
  if (changeType !== 'delete') {
    await updateDocumentRelationships(projectId, docId);
  }
}
```

### ì„±ëŠ¥ ìµœì í™”

**íŒŒì‹± ì†ë„:**
- ì¦ë¶„ íŒŒì‹±: ë³€ê²½ëœ íŒŒì¼ë§Œ ì¬íŒŒì‹±
- ìºì‹±: AST ê²°ê³¼ Redis ìºì‹± (30ë¶„)
- ë³‘ë ¬ ì²˜ë¦¬: ì—¬ëŸ¬ íŒŒì¼ ë™ì‹œ íŒŒì‹±

**ê²€ìƒ‰ ì†ë„:**
- Elasticsearch: Lexical ê²€ìƒ‰ < 50ms
- Pinecone: Semantic ê²€ìƒ‰ < 100ms
- Reranking: Top 10ë§Œ ì²˜ë¦¬ < 200ms
- ì´ ê²€ìƒ‰ ì‹œê°„: < 400ms

**ë©”ëª¨ë¦¬ íš¨ìœ¨:**
- ë¸”ë¡ ë‹¨ìœ„ ë²¡í„°í™”: ì „ì²´ ë¬¸ì„œ ì•„ë‹Œ ë¸”ë¡ë³„
- Lazy Loading: í•„ìš”í•œ ë¸”ë¡ë§Œ ë¡œë“œ
- ë²¡í„° ì••ì¶•: Product Quantization

## ğŸ¨ í”„ë¡ íŠ¸ì—”ë“œ (Web Viewer)

### ê¸°ìˆ  ìŠ¤íƒ
- **Framework**: Next.js 14 (App Router)
- **UI Library**: React 18
- **Styling**: Tailwind CSS + shadcn/ui
- **ë§ˆí¬ë‹¤ìš´ ë Œë”ë§**:
  - `remark` (íŒŒì‹±)
  - `rehype` (HTML ë³€í™˜)
  - `react-markdown` (ë Œë”ë§)
  - `remark-gfm` (GitHub Flavored Markdown)
  - `remark-frontmatter` (ë©”íƒ€ë°ì´í„°)
- **í™•ì¥ ë Œë”ë§**:
  - `mermaid` (ë‹¤ì´ì–´ê·¸ë¨)
  - `react-csv-viewer` (CSV í…Œì´ë¸”)
  - `react-player` (YouTube/Vimeo ì„ë² ë“œ)
  - `react-syntax-highlighter` (ì½”ë“œ ë¸”ë¡)
- **ì½”ë“œ í•˜ì´ë¼ì´íŒ…**: Shiki
- **ìƒíƒœ ê´€ë¦¬**: Zustand
- **ë°ì´í„° í˜ì¹­**: TanStack Query (React Query)

### í™•ì¥ ë§ˆí¬ë‹¤ìš´ ë Œë”ë§ ì—”ì§„

**í•µì‹¬ ì² í•™**: "ê°„ê²°í•œ ì›ë³¸ + í’ë¶€í•œ ë Œë”ë§"

#### ë Œë”ë§ íŒŒì´í”„ë¼ì¸
```typescript
// lib/markdown/renderer.ts

// 1. ë§ˆí¬ë‹¤ìš´ íŒŒì‹± & ë³€í™˜
const pipeline = unified()
  .use(remarkParse)                    // MD â†’ AST
  .use(remarkGfm)                      // GitHub í™•ì¥
  .use(remarkFrontmatter)              // Frontmatter ì¶”ì¶œ
  .use(remarkExtendedLinks)            // ìŠ¤ë§ˆíŠ¸ ë§í¬ ì²˜ë¦¬ â­
  .use(remarkDataFiles)                // CSV/JSON ê°ì§€ â­
  .use(remarkDiagrams)                 // Mermaid ì²˜ë¦¬ â­
  .use(rehypeRaw)                      // HTML í—ˆìš©
  .use(rehypeHighlight)                // ì½”ë“œ í•˜ì´ë¼ì´íŒ…
  .use(rehypeReact, { components });   // React ì»´í¬ë„ŒíŠ¸ë¡œ ë³€í™˜

// 2. ì»¤ìŠ¤í…€ í”ŒëŸ¬ê·¸ì¸ (í•µì‹¬ ì°¨ë³„í™”)

// CSV/JSON ìë™ ê°ì§€ ë° ë³€í™˜
function remarkDataFiles() {
  return (tree) => {
    visit(tree, 'link', (node) => {
      const url = node.url;

      // CSV ë§í¬ ê°ì§€
      if (url.endsWith('.csv')) {
        node.type = 'csv-embed';
        node.data = { csvPath: url };
      }

      // JSON ë§í¬ ê°ì§€
      if (url.endsWith('.json')) {
        node.type = 'json-embed';
        node.data = { jsonPath: url };
      }
    });
  };
}

// ì™¸ë¶€ ë§í¬ ìë™ ì„ë² ë“œ
function remarkExtendedLinks() {
  return (tree) => {
    visit(tree, 'link', (node) => {
      const url = node.url;

      // YouTube ë§í¬ ê°ì§€
      if (isYouTubeUrl(url)) {
        node.type = 'youtube-embed';
        node.data = { videoId: extractYouTubeId(url) };
      }

      // GitHub ë§í¬ ë¯¸ë¦¬ë³´ê¸°
      if (isGitHubUrl(url)) {
        node.type = 'github-preview';
        node.data = { repoUrl: url };
      }
    });
  };
}

// 3. ì»¤ìŠ¤í…€ React ì»´í¬ë„ŒíŠ¸ ë§¤í•‘
const components = {
  // CSV ìë™ í…Œì´ë¸”
  'csv-embed': ({ csvPath }) => (
    <CSVTable
      path={csvPath}
      sortable
      filterable
      downloadable
    />
  ),

  // JSON êµ¬ì¡°í™” ë·°
  'json-embed': ({ jsonPath }) => (
    <JSONViewer
      path={jsonPath}
      expandable
    />
  ),

  // YouTube ì„ë² ë“œ
  'youtube-embed': ({ videoId }) => (
    <YouTubePlayer
      videoId={videoId}
      responsive
    />
  ),

  // Mermaid ë‹¤ì´ì–´ê·¸ë¨
  'code.language-mermaid': ({ children }) => (
    <MermaidDiagram code={children} />
  ),

  // ì½”ë“œ ë¸”ë¡ (ë³µì‚¬ ë²„íŠ¼ í¬í•¨)
  'code': ({ className, children }) => (
    <CodeBlock
      language={className?.replace('language-', '')}
      code={children}
      copyable
    />
  ),

  // ì´ë¯¸ì§€ ìµœì í™”
  'img': ({ src, alt }) => (
    <OptimizedImage
      src={src}
      alt={alt}
      lazyLoad
      lightbox
    />
  )
};
```

#### í•µì‹¬ ì»´í¬ë„ŒíŠ¸ ìƒì„¸

**1. CSV í…Œì´ë¸” ë Œë”ëŸ¬**
```typescript
// components/markdown/CSVTable.tsx
interface CSVTableProps {
  path: string;           // CSV íŒŒì¼ ê²½ë¡œ
  sortable?: boolean;     // ì •ë ¬ ê°€ëŠ¥ ì—¬ë¶€
  filterable?: boolean;   // í•„í„°ë§ ê°€ëŠ¥ ì—¬ë¶€
  downloadable?: boolean; // ë‹¤ìš´ë¡œë“œ ê°€ëŠ¥ ì—¬ë¶€
}

function CSVTable({ path, sortable, filterable, downloadable }: CSVTableProps) {
  const { data, loading } = useCSVData(path);
  const [sortColumn, setSortColumn] = useState<string | null>(null);
  const [filterText, setFilterText] = useState('');

  // CSV íŒŒì‹±
  const parsedData = useMemo(() => {
    return Papa.parse(data, { header: true });
  }, [data]);

  // ì •ë ¬ ë¡œì§
  const sortedData = useMemo(() => {
    if (!sortColumn) return parsedData.data;
    return [...parsedData.data].sort((a, b) => {
      return a[sortColumn] > b[sortColumn] ? 1 : -1;
    });
  }, [parsedData, sortColumn]);

  // í•„í„°ë§ ë¡œì§
  const filteredData = useMemo(() => {
    if (!filterText) return sortedData;
    return sortedData.filter(row =>
      Object.values(row).some(val =>
        String(val).toLowerCase().includes(filterText.toLowerCase())
      )
    );
  }, [sortedData, filterText]);

  return (
    <div className="csv-table-container">
      <div className="toolbar">
        <span>ğŸ“Š {path} ({filteredData.length} rows)</span>
        {filterable && (
          <input
            placeholder="Search..."
            onChange={(e) => setFilterText(e.target.value)}
          />
        )}
        {downloadable && (
          <button onClick={() => downloadCSV(data, path)}>
            â¬‡ Download
          </button>
        )}
      </div>

      <table>
        <thead>
          <tr>
            {parsedData.meta.fields.map(field => (
              <th
                key={field}
                onClick={() => sortable && setSortColumn(field)}
                className={sortable ? 'sortable' : ''}
              >
                {field}
                {sortColumn === field && ' â–¼'}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {filteredData.map((row, idx) => (
            <tr key={idx}>
              {parsedData.meta.fields.map(field => (
                <td key={field}>{row[field]}</td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

**2. JSON ë·°ì–´**
```typescript
// components/markdown/JSONViewer.tsx
interface JSONViewerProps {
  path: string;
  expandable?: boolean;
}

function JSONViewer({ path, expandable }: JSONViewerProps) {
  const { data, loading } = useJSONData(path);

  // API ì—”ë“œí¬ì¸íŠ¸ í˜•ì‹ ê°ì§€
  const isAPIEndpoint = data.every(item =>
    'method' in item && 'path' in item
  );

  if (isAPIEndpoint) {
    return (
      <div className="api-endpoints">
        {data.map(endpoint => (
          <div key={endpoint.path} className="endpoint-card">
            <div className="method">{endpoint.method}</div>
            <div className="path">{endpoint.path}</div>
            <div className="description">{endpoint.description}</div>
            {endpoint.auth && <div className="badge">ğŸ”’ Auth Required</div>}
          </div>
        ))}
      </div>
    );
  }

  // ì¼ë°˜ JSON
  return (
    <ReactJson
      src={data}
      collapsed={!expandable}
      theme="monokai"
    />
  );
}
```

**3. Mermaid ë‹¤ì´ì–´ê·¸ë¨**
```typescript
// components/markdown/MermaidDiagram.tsx
function MermaidDiagram({ code }: { code: string }) {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (containerRef.current) {
      mermaid.render('mermaid-diagram', code).then(({ svg }) => {
        containerRef.current.innerHTML = svg;
      });
    }
  }, [code]);

  return <div ref={containerRef} className="mermaid-diagram" />;
}
```

**4. ìŠ¤ë§ˆíŠ¸ ë§í¬ í”„ë¦¬ë·°**
```typescript
// components/markdown/LinkPreview.tsx
function GitHubPreview({ repoUrl }: { repoUrl: string }) {
  const { repo, loading } = useGitHubRepo(repoUrl);

  if (loading) return <a href={repoUrl}>{repoUrl}</a>;

  return (
    <div className="github-preview-card">
      <div className="header">
        <span className="icon">ğŸ”—</span>
        <span className="repo-name">{repo.full_name}</span>
      </div>
      <p className="description">{repo.description}</p>
      <div className="stats">
        <span>â­ {repo.stargazers_count}</span>
        <span>ğŸ´ {repo.forks_count}</span>
        <span>ğŸ“ {repo.language}</span>
      </div>
    </div>
  );
}
```

### ì£¼ìš” ì»´í¬ë„ŒíŠ¸

#### 1. ë¬¸ì„œ ë·°ì–´
```typescript
// components/DocumentViewer.tsx
interface DocumentViewerProps {
  content: string;        // ë§ˆí¬ë‹¤ìš´ ì›ë¬¸
  metadata: FileMetadata; // íŒŒì¼ ì •ë³´
  projectId: string;      // í”„ë¡œì íŠ¸ ID (ë°ì´í„° íŒŒì¼ ê²½ë¡œ í•´ì„ìš©)
  theme: 'light' | 'dark';
}

function DocumentViewer({ content, metadata, projectId, theme }: DocumentViewerProps) {
  // Frontmatter ì¶”ì¶œ
  const { frontmatter, content: mdContent } = extractFrontmatter(content);

  // ë§ˆí¬ë‹¤ìš´ ë Œë”ë§ (í™•ì¥ í”ŒëŸ¬ê·¸ì¸ í¬í•¨)
  const renderedContent = useMemo(() => {
    return renderMarkdown(mdContent, {
      projectId,  // CSV/JSON ê²½ë¡œ í•´ì„ì— ì‚¬ìš©
      basePath: metadata.path,
      components: customComponents
    });
  }, [mdContent, projectId, metadata.path]);

  return (
    <div className="document-viewer">
      {/* Frontmatter í—¤ë” */}
      {frontmatter && (
        <div className="document-header">
          <h1>{frontmatter.title || metadata.name}</h1>
          <div className="metadata">
            {frontmatter.author && <span>ğŸ‘¤ {frontmatter.author}</span>}
            {frontmatter.date && <span>ğŸ“… {frontmatter.date}</span>}
            {frontmatter.tags && (
              <div className="tags">
                {frontmatter.tags.map(tag => (
                  <span key={tag} className="tag">ğŸ·ï¸ {tag}</span>
                ))}
              </div>
            )}
          </div>
        </div>
      )}

      {/* ë Œë”ë§ëœ ì½˜í…ì¸  */}
      <div className="markdown-content">
        {renderedContent}
      </div>
    </div>
  );
}
```

#### 2. í´ë” ë„¤ë¹„ê²Œì´ì…˜
```typescript
// components/FolderTree.tsx
interface FolderTreeProps {
  structure: FolderNode[];  // í´ë” êµ¬ì¡°
  currentPath: string;
  onNavigate: (path: string) => void;
}

// ê¸°ëŠ¥:
// - ì ‘ì„ ìˆ˜ ìˆëŠ” íŠ¸ë¦¬ êµ¬ì¡°
// - ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì§€ì› (ë¯¸ë˜)
// - ê²€ìƒ‰ í•„í„°ë§
// - ì¦ê²¨ì°¾ê¸°
```

#### 3. ê²€ìƒ‰ ì¸í„°í˜ì´ìŠ¤
```typescript
// components/SearchModal.tsx
interface SearchModalProps {
  projectId: string;
  onSelect: (fileId: string) => void;
}

// ê¸°ëŠ¥:
// - ì‹¤ì‹œê°„ ê²€ìƒ‰ (debounce)
// - í•˜ì´ë¼ì´íŒ…
// - í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ (Cmd+K)
// - ìµœê·¼ ê²€ìƒ‰ì–´
```

#### 4. AI ì±—ë´‡ (Phase 2)
```typescript
// components/AIChatbot.tsx
interface AIChatbotProps {
  projectId: string;
  context: string[]; // í˜„ì¬ ë³´ëŠ” ë¬¸ì„œë“¤
}

// ê¸°ëŠ¥:
// - ë¬¸ì„œ ê¸°ë°˜ Q&A
// - ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ
// - ì†ŒìŠ¤ ì¸ìš© (ì–´ë–¤ ë¬¸ì„œì—ì„œ ë‹µë³€)
// - ëŒ€í™” íˆìŠ¤í† ë¦¬
```

### í˜ì´ì§€ êµ¬ì¡°
```
/                          â†’ ëœë”© í˜ì´ì§€
/login                     â†’ ë¡œê·¸ì¸/íšŒì›ê°€ì…
/dashboard                 â†’ ë‚´ í”„ë¡œì íŠ¸ ëª©ë¡
/p/[projectId]            â†’ í”„ë¡œì íŠ¸ í™ˆ
/p/[projectId]/f/[...path] â†’ íŒŒì¼ ë·°ì–´
/p/[projectId]/search     â†’ ê²€ìƒ‰ ê²°ê³¼
/p/[projectId]/settings   â†’ í”„ë¡œì íŠ¸ ì„¤ì •
/account                  â†’ ê³„ì • ì„¤ì •
/pricing                  â†’ ìš”ê¸ˆì œ
```

## ğŸ’» ë°±ì—”ë“œ (API Server)

### ê¸°ìˆ  ìŠ¤íƒ
- **Runtime**: Node.js 20 (LTS)
- **Framework**: Fastify (ê³ ì„±ëŠ¥)
- **ORM**: Prisma
- **Database**: PostgreSQL 15
- **Cache**: Redis
- **Storage**: AWS S3 (+ CloudFront CDN)
- **Queue**: BullMQ (ë¹„ë™ê¸° ì‘ì—…)
- **Auth**: JWT + Refresh Token

### ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

```sql
-- ì‚¬ìš©ì
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  name VARCHAR(100),
  plan VARCHAR(20) DEFAULT 'free', -- free, pro, team, enterprise
  storage_used BIGINT DEFAULT 0,
  ai_queries_used INT DEFAULT 0,
  ai_queries_limit INT DEFAULT 100,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- í”„ë¡œì íŠ¸
CREATE TABLE projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  name VARCHAR(200) NOT NULL,
  slug VARCHAR(200) UNIQUE NOT NULL, -- URL-friendly
  description TEXT,
  visibility VARCHAR(20) DEFAULT 'private', -- public, private
  invite_code VARCHAR(50) UNIQUE, -- ì´ˆëŒ€ ë§í¬ìš©
  custom_domain VARCHAR(255), -- í”„ë¦¬ë¯¸ì—„ ê¸°ëŠ¥
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  INDEX idx_slug (slug),
  INDEX idx_user_id (user_id)
);

-- íŒŒì¼
CREATE TABLE files (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  path VARCHAR(1000) NOT NULL, -- í´ë” ê²½ë¡œ í¬í•¨
  name VARCHAR(255) NOT NULL,
  type VARCHAR(50) DEFAULT 'markdown', -- markdown, image, pdf
  size BIGINT NOT NULL,
  s3_key VARCHAR(500) NOT NULL, -- S3 ì €ì¥ ê²½ë¡œ
  md5_hash VARCHAR(32), -- ì¤‘ë³µ ë°©ì§€
  version INT DEFAULT 1,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(project_id, path),
  INDEX idx_project_id (project_id),
  INDEX idx_path (path)
);

-- íŒŒì¼ ë²„ì „ (íˆìŠ¤í† ë¦¬)
CREATE TABLE file_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  file_id UUID REFERENCES files(id) ON DELETE CASCADE,
  version INT NOT NULL,
  s3_key VARCHAR(500) NOT NULL,
  size BIGINT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(file_id, version)
);

-- í”„ë¡œì íŠ¸ ë©¤ë²„
CREATE TABLE project_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  role VARCHAR(20) DEFAULT 'viewer', -- owner, editor, viewer
  joined_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(project_id, user_id),
  INDEX idx_project_user (project_id, user_id)
);

-- AI ë²¡í„° (Phase 2)
CREATE TABLE document_vectors (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  file_id UUID REFERENCES files(id) ON DELETE CASCADE,
  chunk_index INT NOT NULL, -- ë¬¸ì„œë¥¼ ì²­í¬ë¡œ ë‚˜ëˆ”
  content TEXT NOT NULL, -- ì›ë³¸ í…ìŠ¤íŠ¸
  vector_id VARCHAR(100), -- Pinecone ID
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(file_id, chunk_index)
);

-- AI ëŒ€í™” íˆìŠ¤í† ë¦¬ (Phase 2)
CREATE TABLE chat_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE chat_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID REFERENCES chat_sessions(id) ON DELETE CASCADE,
  role VARCHAR(20) NOT NULL, -- user, assistant
  content TEXT NOT NULL,
  sources JSONB, -- ì°¸ì¡°í•œ ë¬¸ì„œ ì •ë³´
  created_at TIMESTAMP DEFAULT NOW()
);
```

### API ì—”ë“œí¬ì¸íŠ¸

#### ì¸ì¦
```
POST   /api/auth/register     íšŒì›ê°€ì…
POST   /api/auth/login        ë¡œê·¸ì¸
POST   /api/auth/refresh      í† í° ê°±ì‹ 
POST   /api/auth/logout       ë¡œê·¸ì•„ì›ƒ
GET    /api/auth/me           ë‚´ ì •ë³´
```

#### í”„ë¡œì íŠ¸
```
GET    /api/projects              ë‚´ í”„ë¡œì íŠ¸ ëª©ë¡
POST   /api/projects              í”„ë¡œì íŠ¸ ìƒì„±
GET    /api/projects/:id          í”„ë¡œì íŠ¸ ìƒì„¸
PUT    /api/projects/:id          í”„ë¡œì íŠ¸ ìˆ˜ì •
DELETE /api/projects/:id          í”„ë¡œì íŠ¸ ì‚­ì œ
POST   /api/projects/:id/invite   ì´ˆëŒ€ ë§í¬ ìƒì„±
POST   /api/projects/join/:code   ì´ˆëŒ€ ì½”ë“œë¡œ ì°¸ì—¬
```

#### íŒŒì¼
```
GET    /api/projects/:id/files              íŒŒì¼ ëª©ë¡ (íŠ¸ë¦¬)
GET    /api/projects/:id/files/:fileId      íŒŒì¼ ë‚´ìš©
GET    /api/projects/:id/files/:fileId/raw  ì›ë³¸ ë‹¤ìš´ë¡œë“œ
GET    /api/projects/:id/files/:fileId/pdf  PDF ë³€í™˜ ë‹¤ìš´ë¡œë“œ
POST   /api/projects/:id/upload             íŒŒì¼ ì—…ë¡œë“œ (CLI/Desktopìš©)
DELETE /api/projects/:id/files/:fileId      íŒŒì¼ ì‚­ì œ (ì†Œìœ ìë§Œ)
```

#### ê²€ìƒ‰
```
GET    /api/projects/:id/search?q=keyword   ì „ì²´ ê²€ìƒ‰
POST   /api/projects/:id/search/semantic    AI ì˜ë¯¸ ê²€ìƒ‰ (Phase 2)
```

#### AI ì±—ë´‡ (Phase 2)
```
POST   /api/projects/:id/chat/sessions      ìƒˆ ëŒ€í™” ì‹œì‘
GET    /api/projects/:id/chat/sessions      ë‚´ ëŒ€í™” ëª©ë¡
POST   /api/projects/:id/chat/messages      ë©”ì‹œì§€ ì „ì†¡
GET    /api/projects/:id/chat/:sessionId    ëŒ€í™” íˆìŠ¤í† ë¦¬
```

#### í†µê³„ (í”„ë¦¬ë¯¸ì—„)
```
GET    /api/projects/:id/analytics/views    ì¡°íšŒìˆ˜
GET    /api/projects/:id/analytics/search   ì¸ê¸° ê²€ìƒ‰ì–´
GET    /api/projects/:id/analytics/files    íŒŒì¼ë³„ í†µê³„
```

## ğŸ–¥ï¸ ë°ìŠ¤í¬í†± ì•± (ì—…ë¡œë“œ í´ë¼ì´ì–¸íŠ¸)

### ê¸°ìˆ  ìŠ¤íƒ
- **Framework**: Electron
- **UI**: React + Tailwind
- **íŒŒì¼ ê°ì§€**: Chokidar (íŒŒì¼ ë³€ê²½ ê°ì§€)
- **ì—…ë¡œë“œ**: multipart/form-data

### ì£¼ìš” ê¸°ëŠ¥

#### 1. í´ë” ì„ íƒ & ì—…ë¡œë“œ
```typescript
interface UploadConfig {
  projectId: string;
  localPath: string;      // ë¡œì»¬ í´ë” ê²½ë¡œ
  excludePatterns: string[]; // .gitignore ìŠ¤íƒ€ì¼
  autoSync: boolean;      // íŒŒì¼ ë³€ê²½ ì‹œ ìë™ ì—…ë¡œë“œ
}

// ì œì™¸ íŒ¨í„´ ì˜ˆì‹œ:
// - node_modules/
// - .git/
// - *.log
// - .DS_Store
```

#### 2. ì—…ë¡œë“œ í”„ë¡œì„¸ìŠ¤
```
1. í´ë” ìŠ¤ìº” â†’ íŒŒì¼ ëª©ë¡ ìƒì„±
2. MD5 í•´ì‹œ ê³„ì‚° â†’ ì¤‘ë³µ íŒŒì¼ ìŠ¤í‚µ
3. ì´ë¯¸ì§€/ì²¨ë¶€íŒŒì¼ ìë™ ê°ì§€
4. ìƒëŒ€ ê²½ë¡œ ë§í¬ ê²€ì¦
5. ì²­í¬ ì—…ë¡œë“œ (ëŒ€ìš©ëŸ‰ íŒŒì¼)
6. ì§„í–‰ ìƒí™© í‘œì‹œ
7. ì™„ë£Œ ì•Œë¦¼
```

#### 3. ë™ê¸°í™” ëª¨ë“œ (ì˜µì…˜)
```typescript
// íŒŒì¼ ë³€ê²½ ê°ì§€ â†’ ìë™ ì—…ë¡œë“œ
watcher.on('change', async (path) => {
  await uploadFile(path);
  showNotification('íŒŒì¼ ë™ê¸°í™” ì™„ë£Œ');
});
```

## ğŸ¤– AI ì„œë¹„ìŠ¤ (Phase 2)

### ê¸°ìˆ  ìŠ¤íƒ
- **ë²¡í„° DB**: Pinecone (ê´€ë¦¬í˜•) or Qdrant (ì˜¤í”ˆì†ŒìŠ¤)
- **ì„ë² ë”©**: OpenAI text-embedding-3-small
- **LLM**: OpenAI GPT-4o-mini (ë¹„ìš© íš¨ìœ¨)
- **í”„ë ˆì„ì›Œí¬**: LangChain

### ì•„í‚¤í…ì²˜

#### 1. ë¬¸ì„œ ì„ë² ë”© íŒŒì´í”„ë¼ì¸
```typescript
// ìƒˆ íŒŒì¼ ì—…ë¡œë“œ ì‹œ ìë™ ì‹¤í–‰
async function embedDocument(fileId: string) {
  const file = await getFile(fileId);
  const content = await downloadFromS3(file.s3_key);

  // ì²­í¬ë¡œ ë‚˜ëˆ„ê¸° (512 í† í° ë‹¨ìœ„)
  const chunks = splitIntoChunks(content, 512);

  // ê° ì²­í¬ ì„ë² ë”©
  for (const [index, chunk] of chunks.entries()) {
    const embedding = await openai.embeddings.create({
      model: 'text-embedding-3-small',
      input: chunk.text
    });

    // Pineconeì— ì €ì¥
    await pinecone.upsert({
      id: `${fileId}_${index}`,
      values: embedding.data[0].embedding,
      metadata: {
        fileId,
        chunkIndex: index,
        text: chunk.text,
        path: file.path
      }
    });

    // DBì— ë©”íƒ€ë°ì´í„° ì €ì¥
    await saveChunkMetadata(fileId, index, chunk.text);
  }
}
```

#### 2. AI ê²€ìƒ‰ (Semantic Search)
```typescript
async function semanticSearch(projectId: string, query: string) {
  // ì¿¼ë¦¬ ì„ë² ë”©
  const queryEmbedding = await openai.embeddings.create({
    model: 'text-embedding-3-small',
    input: query
  });

  // ìœ ì‚¬ ë¬¸ì„œ ê²€ìƒ‰
  const results = await pinecone.query({
    vector: queryEmbedding.data[0].embedding,
    topK: 5,
    filter: { projectId }
  });

  // ê´€ë ¨ ë¬¸ì„œ ë°˜í™˜
  return results.matches.map(match => ({
    fileId: match.metadata.fileId,
    path: match.metadata.path,
    snippet: match.metadata.text,
    score: match.score
  }));
}
```

#### 3. ì±—ë´‡ (RAG)
```typescript
async function chatWithDocuments(
  projectId: string,
  question: string,
  conversationHistory: Message[]
) {
  // 1. ê´€ë ¨ ë¬¸ì„œ ê²€ìƒ‰
  const relevantDocs = await semanticSearch(projectId, question);

  // 2. ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±
  const context = relevantDocs
    .map(doc => `[${doc.path}]\n${doc.snippet}`)
    .join('\n\n');

  // 3. LLM í˜¸ì¶œ
  const response = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [
      {
        role: 'system',
        content: `ë‹¹ì‹ ì€ ë¬¸ì„œ ê¸°ë°˜ Q&A ë´‡ì…ë‹ˆë‹¤.
                  ì£¼ì–´ì§„ ë¬¸ì„œ ë‚´ìš©ë§Œì„ ê¸°ë°˜ìœ¼ë¡œ ë‹µë³€í•˜ì„¸ìš”.
                  ë‹µë³€ ì‹œ ì¶œì²˜ë¥¼ ëª…ì‹œí•˜ì„¸ìš”.`
      },
      ...conversationHistory,
      {
        role: 'user',
        content: `ë¬¸ì„œ ë‚´ìš©:\n${context}\n\nì§ˆë¬¸: ${question}`
      }
    ],
    stream: true // ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¬ë°
  });

  // 4. ì†ŒìŠ¤ ì¶”ì¶œ
  const sources = relevantDocs.map(doc => ({
    fileId: doc.fileId,
    path: doc.path,
    relevanceScore: doc.score
  }));

  return { response, sources };
}
```

#### 4. AI ìë™ ì¸ë±ì‹± ì‹œìŠ¤í…œ â­ í•µì‹¬ ì°¨ë³„í™”

**ëª©í‘œ**: ì‚¬ìš©ìê°€ 100ê°œ ë¬¸ì„œë¥¼ ì—…ë¡œë“œí•˜ë©´, AIê°€ 5ë¶„ ì•ˆì— ëª¨ë“  ì¸ë±ìŠ¤ë¥¼ ìë™ ìƒì„±

```typescript
// ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… í (BullMQ)
async function queueAutoIndexing(projectId: string) {
  await indexQueue.add('generate-indexes', {
    projectId,
    tasks: [
      'topic-clustering',      // ì£¼ì œë³„ ë¶„ë¥˜
      'date-timeline',         // ë‚ ì§œë³„ íƒ€ì„ë¼ì¸
      'author-grouping',       // ì‘ì„±ìë³„
      'category-extraction',   // ì¹´í…Œê³ ë¦¬ë³„
      'relationship-analysis', // ë¬¸ì„œ ê´€ê³„
      'ai-structure-suggestion' // AI ì¶”ì²œ êµ¬ì¡°
    ]
  }, {
    priority: 2,  // ë†’ì€ ìš°ì„ ìˆœìœ„
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 2000
    }
  });
}

// ì¸ë±ìŠ¤ ìƒì„± ì›Œì»¤
indexQueue.process('generate-indexes', async (job) => {
  const { projectId, tasks } = job.data;
  const allDocs = await getAllDocuments(projectId);

  // ë³‘ë ¬ ì‹¤í–‰ìœ¼ë¡œ ì„±ëŠ¥ ìµœì í™”
  await Promise.all([
    tasks.includes('topic-clustering') && generateTopicIndex(projectId, allDocs),
    tasks.includes('date-timeline') && generateDateIndex(projectId, allDocs),
    tasks.includes('author-grouping') && generateAuthorIndex(projectId, allDocs),
    tasks.includes('category-extraction') && generateCategoryIndex(projectId, allDocs),
    tasks.includes('relationship-analysis') && generateRelationshipIndex(projectId, allDocs),
    tasks.includes('ai-structure-suggestion') && generateAISuggestionIndex(projectId, allDocs)
  ].filter(Boolean));

  // ì¸ë±ìŠ¤ ì™„ë£Œ ì´ë²¤íŠ¸
  await notifyUser(projectId, 'indexes-ready');
});

// ì£¼ì œë³„ ì¸ë±ìŠ¤ ìƒì„± (K-means í´ëŸ¬ìŠ¤í„°ë§)
async function generateTopicIndex(projectId: string, docs: ParsedDocument[]) {
  // 1. ë¬¸ì„œ ë²¡í„° ìˆ˜ì§‘
  const vectors = docs.map(doc => ({
    id: doc.id,
    vector: averageBlockVectors(doc.blocks),
    metadata: doc.metadata
  }));

  // 2. ìµœì  í´ëŸ¬ìŠ¤í„° ìˆ˜ ê²°ì • (Elbow Method)
  const optimalK = findOptimalClusters(vectors, { minK: 3, maxK: 10 });

  // 3. K-means í´ëŸ¬ìŠ¤í„°ë§
  const clusters = performKMeans(vectors, optimalK);

  // 4. ê° í´ëŸ¬ìŠ¤í„°ì— ì£¼ì œ ë ˆì´ë¸” ë¶€ì—¬ (LLM)
  const labeledClusters = await Promise.all(
    clusters.map(async (cluster) => {
      const titles = cluster.members.map(m => m.metadata.title).join('\n');
      const label = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [{
          role: 'system',
          content: 'ë‹¤ìŒ ë¬¸ì„œ ì œëª©ë“¤ì˜ ê³µí†µ ì£¼ì œë¥¼ í•œê¸€ 2-3ë‹¨ì–´ë¡œ ìš”ì•½í•˜ì„¸ìš”.'
        }, {
          role: 'user',
          content: titles
        }],
        temperature: 0.3
      });

      return {
        topic: label.choices[0].message.content,
        documents: cluster.members,
        coherence: cluster.coherenceScore
      };
    })
  );

  // 5. Markdown ì¸ë±ìŠ¤ ìƒì„±
  const markdown = formatTopicIndexMarkdown(labeledClusters);

  // 6. .index/ í´ë”ì— ì €ì¥
  await saveIndexFile(projectId, '.index/by-topic.md', markdown);

  return labeledClusters;
}

// ë¬¸ì„œ ê´€ê³„ ê·¸ë˜í”„ ìƒì„±
async function generateRelationshipIndex(projectId: string, docs: ParsedDocument[]) {
  const graph: DocumentGraph = {
    nodes: docs.map(doc => ({
      id: doc.id,
      title: doc.metadata.title,
      category: doc.metadata.category,
      tags: doc.metadata.tags
    })),
    edges: []
  };

  // 1. ëª…ì‹œì  ë§í¬ ì¶”ì¶œ
  for (const doc of docs) {
    const internalLinks = doc.structure.links.filter(l => l.type === 'internal');
    for (const link of internalLinks) {
      graph.edges.push({
        source: doc.id,
        target: resolveDocId(link.href, docs),
        type: 'explicit',
        weight: 1.0
      });
    }
  }

  // 2. ë²¡í„° ìœ ì‚¬ë„ ê¸°ë°˜ ì•”ì‹œì  ê´€ê³„
  for (let i = 0; i < docs.length; i++) {
    const doc1Vector = averageBlockVectors(docs[i].blocks);

    for (let j = i + 1; j < docs.length; j++) {
      const doc2Vector = averageBlockVectors(docs[j].blocks);
      const similarity = cosineSimilarity(doc1Vector, doc2Vector);

      // ìœ ì‚¬ë„ 0.7 ì´ìƒë§Œ ê´€ê³„ë¡œ ì¸ì •
      if (similarity >= 0.7) {
        graph.edges.push({
          source: docs[i].id,
          target: docs[j].id,
          type: 'semantic',
          weight: similarity
        });
      }
    }
  }

  // 3. Frontmatter parent/children ê´€ê³„
  for (const doc of docs) {
    if (doc.metadata.parent) {
      graph.edges.push({
        source: doc.id,
        target: doc.metadata.parent,
        type: 'hierarchical',
        weight: 1.0,
        direction: 'child-to-parent'
      });
    }
  }

  // 4. Markdown ê´€ê³„ ê·¸ë˜í”„ ìƒì„± (Mermaid ë‹¤ì´ì–´ê·¸ë¨ í¬í•¨)
  const markdown = formatRelationshipMarkdown(graph);
  await saveIndexFile(projectId, '.index/related-docs.md', markdown);

  return graph;
}

// AI ì¶”ì²œ êµ¬ì¡° ìƒì„±
async function generateAISuggestionIndex(projectId: string, docs: ParsedDocument[]) {
  // 1. ë¬¸ì„œ í’ˆì§ˆ ë¶„ì„
  const analysis = docs.map(doc => ({
    id: doc.id,
    title: doc.metadata.title,
    aiScore: doc.metadata.aiScore,
    issues: identifyDocumentIssues(doc)
  }));

  // 2. ê°œì„ ì´ í•„ìš”í•œ ë¬¸ì„œ ì‹ë³„
  const needsImprovement = analysis
    .filter(a => a.aiScore < 60)
    .sort((a, b) => a.aiScore - b.aiScore);

  // 3. ê³ ë¦½ëœ ë¬¸ì„œ ì°¾ê¸° (ë§í¬ ì—†ìŒ)
  const isolated = docs.filter(doc => {
    const hasIncoming = docs.some(d =>
      d.structure.links.some(l => l.href.includes(doc.id))
    );
    const hasOutgoing = doc.structure.links.filter(l => l.type === 'internal').length > 0;
    return !hasIncoming && !hasOutgoing;
  });

  // 4. ì¤‘ë³µ ê°€ëŠ¥ì„±ì´ ìˆëŠ” ë¬¸ì„œ (ë²¡í„° ìœ ì‚¬ë„ 0.9 ì´ìƒ)
  const duplicates = findPotentialDuplicates(docs, { threshold: 0.9 });

  // 5. AI ì¶”ì²œ ìƒì„± (LLM)
  const suggestions = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [{
      role: 'system',
      content: `ë¬¸ì„œ ë¶„ì„ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ê°œì„  ë°©ì•ˆì„ ì œì•ˆí•˜ì„¸ìš”.
                - í´ë” êµ¬ì¡° ì¬êµ¬ì„±
                - ë¬¸ì„œ ë³‘í•©/ë¶„ë¦¬ ì œì•ˆ
                - ëˆ„ë½ëœ ë¬¸ì„œ ì œì•ˆ
                - í•™ìŠµ ê²½ë¡œ ì œì•ˆ`
    }, {
      role: 'user',
      content: JSON.stringify({
        totalDocs: docs.length,
        lowQuality: needsImprovement.length,
        isolated: isolated.length,
        duplicates: duplicates.length,
        categories: [...new Set(docs.map(d => d.metadata.category))],
        topics: [...new Set(docs.flatMap(d => d.metadata.tags || []))]
      })
    }],
    temperature: 0.5
  });

  // 6. Markdown ìƒì„±
  const markdown = formatAISuggestionMarkdown({
    needsImprovement,
    isolated,
    duplicates,
    aiSuggestions: suggestions.choices[0].message.content
  });

  await saveIndexFile(projectId, '.index/ai-suggested.md', markdown);

  return suggestions;
}
```

#### 5. AI ì¹œí™”ë„ ì‹¤ì‹œê°„ í‰ê°€

```typescript
// ë¬¸ì„œ ì—…ë¡œë“œ/ìˆ˜ì • ì‹œ ìë™ í‰ê°€
async function evaluateDocumentAIFriendliness(
  doc: ParsedDocument
): Promise<AIFriendlinessReport> {

  const report: AIFriendlinessReport = {
    score: 0,
    breakdown: {},
    suggestions: [],
    examples: []
  };

  // 1. Frontmatter ì™„ì„±ë„ (30ì )
  const frontmatterScore = evaluateFrontmatter(doc.metadata);
  report.breakdown.frontmatter = frontmatterScore;
  report.score += frontmatterScore.score;

  if (frontmatterScore.score < 20) {
    report.suggestions.push({
      category: 'frontmatter',
      severity: 'high',
      message: 'Frontmatter í•„ìˆ˜ í•„ë“œ ëˆ„ë½',
      fix: `ë‹¤ìŒ í•„ë“œë¥¼ ì¶”ê°€í•˜ì„¸ìš”: ${frontmatterScore.missing.join(', ')}`,
      example: `---
title: ${doc.metadata.title || 'ë¬¸ì„œ ì œëª©'}
summary: ì´ ë¬¸ì„œëŠ” ...ì— ëŒ€í•œ ì„¤ëª…ì…ë‹ˆë‹¤
tags: [tag1, tag2, tag3]
category: ì¹´í…Œê³ ë¦¬ëª…
---`
    });
  }

  // 2. êµ¬ì¡°í™” ìˆ˜ì¤€ (30ì )
  const structureScore = evaluateStructure(doc.structure);
  report.breakdown.structure = structureScore;
  report.score += structureScore.score;

  if (!structureScore.hasHeadings) {
    report.suggestions.push({
      category: 'structure',
      severity: 'high',
      message: 'ì œëª©ì´ ì—†ì–´ ë¬¸ì„œ êµ¬ì¡°ë¥¼ íŒŒì•…í•˜ê¸° ì–´ë µìŠµë‹ˆë‹¤',
      fix: '# ì£¼ì œëª©, ## ì†Œì œëª© í˜•ì‹ìœ¼ë¡œ ê³„ì¸µì  êµ¬ì¡° ì¶”ê°€',
      example: `# ë©”ì¸ ì£¼ì œ
## ì„¹ì…˜ 1
ë‚´ìš©...

## ì„¹ì…˜ 2
ë‚´ìš©...`
    });
  }

  // 3. ë‚´ìš© ëª…í™•ì„± (20ì )
  const clarityScore = evaluateClarity(doc.blocks);
  report.breakdown.clarity = clarityScore;
  report.score += clarityScore.score;

  if (clarityScore.tooLong) {
    report.suggestions.push({
      category: 'clarity',
      severity: 'medium',
      message: 'ì¼ë¶€ ë¬¸ë‹¨ì´ ë„ˆë¬´ ê¸¸ì–´ AIê°€ ì´í•´í•˜ê¸° ì–´ë µìŠµë‹ˆë‹¤',
      fix: 'ê¸´ ë¬¸ë‹¨ì„ ë¦¬ìŠ¤íŠ¸ë‚˜ ì—¬ëŸ¬ ë¬¸ë‹¨ìœ¼ë¡œ ë‚˜ëˆ„ì„¸ìš”',
      example: `âŒ ë‚˜ìœ ì˜ˆ:
ì´ ì‹œìŠ¤í…œì€ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ë¥¼ ì‚¬ìš©í•˜ë©° ê° ì„œë¹„ìŠ¤ëŠ” ë…ë¦½ì ìœ¼ë¡œ ë°°í¬...

âœ… ì¢‹ì€ ì˜ˆ:
**ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜:**
- ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ê¸°ë°˜
- ë…ë¦½ ë°°í¬ ê°€ëŠ¥
- ì„œë¹„ìŠ¤ ê°„ REST API í†µì‹ `
    });
  }

  // 4. ë§í¬ ë° ê´€ê³„ (20ì )
  const linksScore = evaluateLinks(doc.structure, doc.metadata);
  report.breakdown.links = linksScore;
  report.score += linksScore.score;

  if (linksScore.isolated) {
    report.suggestions.push({
      category: 'links',
      severity: 'medium',
      message: 'ì´ ë¬¸ì„œëŠ” ë‹¤ë¥¸ ë¬¸ì„œì™€ ì—°ê²°ë˜ì§€ ì•Šì•„ ê³ ë¦½ë˜ì–´ ìˆìŠµë‹ˆë‹¤',
      fix: 'related_docs í•„ë“œì— ê´€ë ¨ ë¬¸ì„œë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ë‚´ë¶€ ë§í¬ë¥¼ ì‚½ì…í•˜ì„¸ìš”',
      example: `---
related_docs: [guide.md, tutorial.md, faq.md]
---

ë˜ëŠ” ë³¸ë¬¸ì—:
ìì„¸í•œ ë‚´ìš©ì€ [ì‚¬ìš©ì ê°€ì´ë“œ](./guide.md)ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”.`
    });
  }

  // 5. ì „ì²´ ë“±ê¸‰ ë¶€ì—¬
  report.grade =
    report.score >= 80 ? 'excellent' :
    report.score >= 60 ? 'good' :
    report.score >= 40 ? 'fair' : 'poor';

  report.badge = getScoreBadge(report.score);

  return report;
}

// ì ìˆ˜ì— ë”°ë¥¸ ë°°ì§€
function getScoreBadge(score: number): string {
  if (score >= 80) return 'ğŸ† ìš°ìˆ˜ (AIê°€ ì™„ë²½í•˜ê²Œ ì´í•´)';
  if (score >= 60) return 'ğŸ‘ ì–‘í˜¸ (AIê°€ ì˜ ì´í•´)';
  if (score >= 40) return 'âš ï¸ ë³´í†µ (ê°œì„  í•„ìš”)';
  return 'âŒ ë¯¸í¡ (AI ì´í•´ ì–´ë ¤ì›€)';
}
```

#### 6. ì„±ëŠ¥ & ë¹„ìš© ìµœì í™”

**ì„ë² ë”© ë¹„ìš© ì ˆê°:**
```typescript
// 1. ì¦ë¶„ ë²¡í„°í™”: ë³€ê²½ëœ ë¸”ë¡ë§Œ ì¬ì²˜ë¦¬
async function incrementalEmbedding(
  oldDoc: ParsedDocument,
  newDoc: ParsedDocument
) {
  const changedBlocks = detectChangedBlocks(oldDoc.blocks, newDoc.blocks);

  // ë³€ê²½ëœ ë¸”ë¡ë§Œ ë²¡í„°í™”
  const embeddings = await Promise.all(
    changedBlocks.map(block => embedText(block.content))
  );

  // Pinecone ì—…ë°ì´íŠ¸ (ì „ì²´ ì¬ìƒì„± X)
  await pinecone.upsert(
    changedBlocks.map((block, i) => ({
      id: block.id,
      values: embeddings[i],
      metadata: { ...block.metadata }
    }))
  );

  // ë¹„ìš© ì ˆê° ì˜ˆì‹œ:
  // 100ê°œ ë¬¸ì„œ, í‰ê·  20ë¸”ë¡ = 2000 ë¸”ë¡
  // ì „ì²´ ì¬ì²˜ë¦¬: $0.40 (2000 * $0.0002)
  // ì¦ë¶„ ì²˜ë¦¬ (10% ë³€ê²½): $0.04 (200 * $0.0002)
  // â†’ 90% ë¹„ìš© ì ˆê°
}

// 2. ìºì‹±: ë™ì¼ í…ìŠ¤íŠ¸ ì¬ì‚¬ìš©
const embeddingCache = new Map<string, number[]>();

async function cachedEmbed(text: string): Promise<number[]> {
  const hash = md5(text);

  if (embeddingCache.has(hash)) {
    return embeddingCache.get(hash);
  }

  const embedding = await embedText(text);
  embeddingCache.set(hash, embedding);
  return embedding;
}

// 3. ë°°ì¹˜ ì²˜ë¦¬: API í˜¸ì¶œ ìµœì†Œí™”
async function batchEmbed(texts: string[]): Promise<number[][]> {
  // OpenAI ë°°ì¹˜ API: ìµœëŒ€ 2048ê°œ
  const batches = chunk(texts, 2048);

  const results = await Promise.all(
    batches.map(batch =>
      openai.embeddings.create({
        model: 'text-embedding-3-small',
        input: batch
      })
    )
  );

  return results.flatMap(r => r.data.map(d => d.embedding));
}
```

**ê²€ìƒ‰ ì„±ëŠ¥:**
```typescript
// Phaseë³„ ì„±ëŠ¥ ëª©í‘œ

// Phase 1 (MVP): í‚¤ì›Œë“œ ê²€ìƒ‰ë§Œ
// - Elasticsearch BM25
// - ì‘ë‹µ ì‹œê°„: < 100ms
// - ë¹„ìš©: $20/ì›” (Bonsai starter)

// Phase 2 (AI í†µí•©): í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰
// - Elasticsearch + Pinecone
// - ì‘ë‹µ ì‹œê°„: < 400ms
// - ë¹„ìš©: $100/ì›” (Pinecone Starter + Elasticsearch)

// Phase 3 (ìµœì í™”): Reranking ì¶”ê°€
// - + Cohere Rerank API
// - ì‘ë‹µ ì‹œê°„: < 600ms
// - ì •í™•ë„: 95%+
// - ë¹„ìš©: $200/ì›”
```

## ğŸ”’ ë³´ì•ˆ ì„¤ê³„

### ì¸ì¦ & ì¸ê°€
```typescript
// JWT í† í° êµ¬ì¡°
interface JWTPayload {
  userId: string;
  email: string;
  plan: 'free' | 'pro' | 'team' | 'enterprise';
  iat: number; // issued at
  exp: number; // expiration
}

// Access Token: 15ë¶„
// Refresh Token: 7ì¼ (httpOnly cookie)

// ê¶Œí•œ ì²´í¬ ë¯¸ë“¤ì›¨ì–´
async function checkProjectAccess(
  userId: string,
  projectId: string,
  requiredRole: 'viewer' | 'editor' | 'owner'
) {
  const project = await getProject(projectId);

  // Public í”„ë¡œì íŠ¸ëŠ” ëˆ„êµ¬ë‚˜ ì½ê¸° ê°€ëŠ¥
  if (project.visibility === 'public' && requiredRole === 'viewer') {
    return true;
  }

  // ë©¤ë²„ í™•ì¸
  const member = await getProjectMember(projectId, userId);
  if (!member) throw new Error('Access denied');

  // ì—­í•  ì²´í¬
  const roleHierarchy = { viewer: 1, editor: 2, owner: 3 };
  if (roleHierarchy[member.role] < roleHierarchy[requiredRole]) {
    throw new Error('Insufficient permissions');
  }

  return true;
}
```

### Rate Limiting
```typescript
// API ìš”ì²­ ì œí•œ
const rateLimits = {
  free: {
    search: 100,    // 100 req/hour
    aiChat: 10,     // 10 req/hour
    upload: 50      // 50 req/day
  },
  pro: {
    search: 1000,
    aiChat: 100,
    upload: 500
  }
};

// Redisë¡œ êµ¬í˜„
async function checkRateLimit(userId: string, action: string) {
  const key = `ratelimit:${userId}:${action}`;
  const count = await redis.incr(key);

  if (count === 1) {
    await redis.expire(key, 3600); // 1ì‹œê°„
  }

  const limit = rateLimits[user.plan][action];
  if (count > limit) {
    throw new Error('Rate limit exceeded');
  }
}
```

### íŒŒì¼ ë³´ì•ˆ
```typescript
// S3 Presigned URL (ì‹œê°„ ì œí•œ)
async function getSecureFileUrl(fileId: string, userId: string) {
  // ê¶Œí•œ í™•ì¸
  await checkProjectAccess(userId, file.projectId, 'viewer');

  // 15ë¶„ ìœ íš¨ URL ìƒì„±
  const url = await s3.getSignedUrlPromise('getObject', {
    Bucket: 'mdshare-files',
    Key: file.s3_key,
    Expires: 900 // 15ë¶„
  });

  return url;
}
```

## ğŸ“Š ì„±ëŠ¥ ìµœì í™”

### ìºì‹± ì „ëµ
```typescript
// 1. CDN ìºì‹± (ì •ì  íŒŒì¼)
// CloudFront: 1ë…„ (ì´ë¯¸ì§€, CSS, JS)

// 2. Redis ìºì‹± (ë™ì  ë°ì´í„°)
const cacheStrategy = {
  projectMetadata: 3600,    // 1ì‹œê°„
  fileList: 600,            // 10ë¶„
  fileContent: 1800,        // 30ë¶„
  searchResults: 300        // 5ë¶„
};

// ìºì‹œ í—¬í¼
async function getCached<T>(
  key: string,
  ttl: number,
  fetchFn: () => Promise<T>
): Promise<T> {
  const cached = await redis.get(key);
  if (cached) return JSON.parse(cached);

  const data = await fetchFn();
  await redis.setex(key, ttl, JSON.stringify(data));
  return data;
}
```

### ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”
```sql
-- ì¸ë±ìŠ¤ ì „ëµ
CREATE INDEX idx_files_project_path ON files(project_id, path);
CREATE INDEX idx_files_updated ON files(updated_at DESC);
CREATE INDEX idx_members_project_user ON project_members(project_id, user_id);

-- íŒŒí‹°ì…”ë‹ (ëŒ€ìš©ëŸ‰ ë°ì´í„°)
CREATE TABLE chat_messages PARTITION BY RANGE (created_at);
```

### ë¡œë”© ìµœì í™”
```typescript
// 1. íŒŒì¼ ëª©ë¡ í˜ì´ì§€ë„¤ì´ì…˜
async function listFiles(projectId: string, page = 1, limit = 50) {
  const offset = (page - 1) * limit;
  return await db.files.findMany({
    where: { projectId },
    skip: offset,
    take: limit,
    orderBy: { updatedAt: 'desc' }
  });
}

// 2. ì¦ë¶„ ë¡œë”© (Infinite Scroll)
// 3. ì´ë¯¸ì§€ lazy loading
// 4. ì½”ë“œ ìŠ¤í”Œë¦¬íŒ… (Next.js dynamic import)
```

## ğŸš€ ë°°í¬ ì•„í‚¤í…ì²˜

### ì¸í”„ë¼ ì„ íƒ
```
í”„ë¡ íŠ¸ì—”ë“œ: Vercel (Next.js ìµœì í™”)
ë°±ì—”ë“œ: Railway or Fly.io (ì‰¬ìš´ ìŠ¤ì¼€ì¼ë§)
ë°ì´í„°ë² ì´ìŠ¤: Supabase (PostgreSQL + ê´€ë¦¬í˜•)
ìŠ¤í† ë¦¬ì§€: AWS S3 + CloudFront
ìºì‹œ: Redis (Railway ë˜ëŠ” Upstash)
ëª¨ë‹ˆí„°ë§: Sentry (ì—ëŸ¬), PostHog (ë¶„ì„)
```

### CI/CD íŒŒì´í”„ë¼ì¸
```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Run tests
        run: npm test

      - name: Build frontend
        run: cd frontend && npm run build

      - name: Deploy to Vercel
        run: vercel --prod

      - name: Deploy backend
        run: railway up

      - name: Run migrations
        run: npx prisma migrate deploy
```

## ğŸ“ ì½”ë“œ í’ˆì§ˆ & í…ŒìŠ¤íŒ…

### í…ŒìŠ¤íŠ¸ ì „ëµ
```typescript
// 1. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (Jest)
describe('File Upload', () => {
  it('should reject files larger than limit', async () => {
    const result = await uploadFile(largeFile);
    expect(result.error).toBe('File too large');
  });
});

// 2. í†µí•© í…ŒìŠ¤íŠ¸ (Supertest)
describe('API /projects', () => {
  it('should create project', async () => {
    const res = await request(app)
      .post('/api/projects')
      .send({ name: 'Test' })
      .expect(201);
  });
});

// 3. E2E í…ŒìŠ¤íŠ¸ (Playwright)
test('user can upload and view document', async ({ page }) => {
  await page.goto('/dashboard');
  await page.click('text=New Project');
  // ... ì—…ë¡œë“œ ì‹œë‚˜ë¦¬ì˜¤
});
```

### ëª¨ë‹ˆí„°ë§
```typescript
// 1. ì—ëŸ¬ ì¶”ì  (Sentry)
Sentry.init({ dsn: process.env.SENTRY_DSN });

// 2. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    const duration = Date.now() - start;
    metrics.record('api.latency', duration, {
      method: req.method,
      path: req.path
    });
  });
  next();
});

// 3. ë¹„ì¦ˆë‹ˆìŠ¤ ë©”íŠ¸ë¦­
trackEvent('file_uploaded', { projectId, fileSize });
trackEvent('ai_query', { projectId, tokens });
```

## ğŸ’¾ ë°±ì—… & ì¬í•´ ë³µêµ¬

### ë°ì´í„° ë°±ì—…
```
PostgreSQL:
- ì¼ì¼ ìë™ ë°±ì—… (Supabase ê¸°ë³¸ ì œê³µ)
- 7ì¼ ë³´ê´€

S3:
- Versioning í™œì„±í™”
- Lifecycle ì •ì±… (30ì¼ í›„ Glacier)
- Cross-region replication (ì—”í„°í”„ë¼ì´ì¦ˆ)

Redis:
- RDB ìŠ¤ëƒ…ìƒ· (6ì‹œê°„ë§ˆë‹¤)
- AOF ë¡œê·¸ (append-only file)
```

### ì¥ì•  ëŒ€ì‘
```typescript
// 1. Circuit Breaker (ì™¸ë¶€ API)
const breaker = new CircuitBreaker(openai.chat, {
  timeout: 30000,
  errorThresholdPercentage: 50,
  resetTimeout: 60000
});

// 2. Graceful Degradation
if (aiServiceDown) {
  return fallbackSearch(query); // í‚¤ì›Œë“œ ê²€ìƒ‰ìœ¼ë¡œ ëŒ€ì²´
}

// 3. Health Check
app.get('/health', async (req, res) => {
  const dbOk = await checkDatabase();
  const redisOk = await checkRedis();
  const s3Ok = await checkS3();

  res.json({
    status: dbOk && redisOk && s3Ok ? 'healthy' : 'degraded',
    services: { db: dbOk, redis: redisOk, s3: s3Ok }
  });
});
```

## ğŸ”® ë¯¸ë˜ í™•ì¥ì„±

### ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì „í™˜ (í•„ìš”ì‹œ)
```
í˜„ì¬ (Monolith):
â”œâ”€ API Gateway
â””â”€ Single Backend

ë¯¸ë˜ (Microservices):
â”œâ”€ API Gateway
â”œâ”€ Auth Service
â”œâ”€ Upload Service
â”œâ”€ View Service
â”œâ”€ AI Service (ë¶„ë¦¬)
â””â”€ Analytics Service
```

### ê¸€ë¡œë²Œ í™•ì¥
```
- ë©€í‹° ë¦¬ì „ ë°°í¬ (US, EU, Asia)
- ì§€ì—­ë³„ S3 ë²„í‚·
- CDN ìµœì í™”
- ë‹¤êµ­ì–´ ì§€ì› (i18n)
```

---

## ğŸŒŸ ì™œ ì´ í•˜ì´ë¸Œë¦¬ë“œ ì•„í‚¤í…ì²˜ê°€ "ëª¨ë˜"í•œê°€?

### í•µì‹¬ ë‹µë³€: ì‚¬ìš©ì ê²½í—˜ê³¼ AI íŒŒì›Œì˜ ì™„ë²½í•œ ê· í˜•

**ë¬¸ì œ ì¸ì‹:**
ìš”ì¦˜ íŠ¸ë Œë“œëŠ” "ëª¨ë“  ê²ƒì„ JSONìœ¼ë¡œ" (Notion, Linear, Airtable ë“± Block-based ì‹œìŠ¤í…œ)ì…ë‹ˆë‹¤. ì´ê²ƒì€ ê°•ë ¥í•˜ì§€ë§Œ, ë³µì¡í•˜ê³  ë°ì´í„° ì¢…ì†ì„±ì´ ë†’ìŠµë‹ˆë‹¤.

**ìš°ë¦¬ì˜ ì„ íƒ:**
í•˜ì´ë¸Œë¦¬ë“œ ì•„í‚¤í…ì²˜ = **Markdown ì†ŒìŠ¤ (ì‚¬ëŒ) + JSON ì²˜ë¦¬ (AI)**

### 1. ì‚¬ìš©ì ê²½í—˜: "ë‹¨ìˆœí•¨ì„ ì§€í‚¨ë‹¤"

```
âŒ ê¸°ì¡´ Block-based ì‹œìŠ¤í…œ (Notion):
ì‚¬ìš©ì â†’ ë³µì¡í•œ ì—ë””í„° â†’ Nested JSON â†’ DB ì €ì¥
- ì§„ì… ì¥ë²½: ë†’ìŒ (íŠ¹ìˆ˜í•œ ì—ë””í„° í•™ìŠµ í•„ìš”)
- ë°ì´í„° ì´ë™: ì–´ë ¤ì›€ (JSON êµ¬ì¡° ì¢…ì†)
- Git í†µí•©: ë¶ˆê°€ëŠ¥

âœ… ìš°ë¦¬ ì‹œìŠ¤í…œ:
ì‚¬ìš©ì â†’ .md íŒŒì¼ ì‘ì„± â†’ ì—…ë¡œë“œ â†’ ë
- ì§„ì… ì¥ë²½: ë‚®ìŒ (VSCode, Obsidian ë“± ììœ ë¡­ê²Œ ì„ íƒ)
- ë°ì´í„° ì´ë™: ì‰¬ì›€ (ìˆœìˆ˜ .md íŒŒì¼)
- Git í†µí•©: ì™„ë²½ (ë²„ì „ ê´€ë¦¬, í˜‘ì—…)
```

**ROI ë¶„ì„:**
- Notion ë§ˆì´ê·¸ë ˆì´ì…˜ ë¹„ìš©: 100 í˜ì´ì§€ = 20ì‹œê°„ (ìˆ˜ë™ ë³€í™˜)
- ìš°ë¦¬ ì‹œìŠ¤í…œ: 100ê°œ .md íŒŒì¼ = 5ë¶„ (í´ë” ë“œë˜ê·¸ & ë“œë¡­)

### 2. AI íŒŒì›Œ: "ë³´ì´ì§€ ì•ŠëŠ” ë˜‘ë˜‘í•¨"

```
ì‚¬ìš©ìê°€ ë³´ëŠ” ê²ƒ:
simple.md (ìˆœìˆ˜ ë§ˆí¬ë‹¤ìš´)

ì‹œìŠ¤í…œ ë‚´ë¶€:
simple.md
  â†’ Parser â†’ AST â†’ JSON
  â†’ Block ë¶„í•´ [heading, paragraph, list, ...]
  â†’ ë²¡í„°í™” [block1: [0.12, -0.33, ...], block2: [...]]
  â†’ Elasticsearch ì¸ë±ì‹±
  â†’ Pinecone ë²¡í„° ì €ì¥
  â†’ ìë™ íƒœê¹…, ê´€ê³„ ë¶„ì„, ëª©ì°¨ ìƒì„±
```

**ì‚¬ìš©ì ì…ì¥:**
"ì–´? ê·¸ëƒ¥ ë§ˆí¬ë‹¤ìš´ íŒŒì¼ ì˜¬ë ¸ëŠ”ë° ìë™ìœ¼ë¡œ ëª©ì°¨ ìƒê²¼ë„¤? ê´€ë ¨ ë¬¸ì„œ ì¶”ì²œë„ ë˜ë„¤?"

**ì‹œìŠ¤í…œ ë‚´ë¶€:**
- 12ë‹¨ê³„ íŒŒì‹± íŒŒì´í”„ë¼ì¸
- K-means í´ëŸ¬ìŠ¤í„°ë§
- ë²¡í„° ìœ ì‚¬ë„ ê³„ì‚°
- LLM íƒœê·¸ ì¶”ì¶œ
- ê´€ê³„ ê·¸ë˜í”„ êµ¬ì¶•

### 3. ë¹„êµ: ì™œ ìˆœìˆ˜ JSON ë°©ì‹ë³´ë‹¤ ë‚˜ì€ê°€?

| ì¸¡ë©´ | ìˆœìˆ˜ JSON (Notion ìŠ¤íƒ€ì¼) | í•˜ì´ë¸Œë¦¬ë“œ (ìš°ë¦¬) |
|------|---------------------------|-------------------|
| **ì‚¬ìš©ì ë³µì¡ë„** | ë†’ìŒ (ì „ìš© ì—ë””í„° í•™ìŠµ) | ë‚®ìŒ (ë§ˆí¬ë‹¤ìš´ë§Œ ì•Œë©´ OK) |
| **ë°ì´í„° ì†Œìœ ê¶Œ** | ë‚®ìŒ (JSON ì¢…ì†) | ë†’ìŒ (.md íŒŒì¼ ì›ë³¸) |
| **AI í™œìš©ë„** | ë†’ìŒ (êµ¬ì¡°í™”ë¨) | ë†’ìŒ (ë‚´ë¶€ì—ì„œ êµ¬ì¡°í™”) |
| **Git í†µí•©** | ë¶ˆê°€ëŠ¥ | ì™„ë²½ |
| **ë§ˆì´ê·¸ë ˆì´ì…˜ ë¹„ìš©** | ë†’ìŒ (ìˆ˜ë™ ë³€í™˜) | ì—†ìŒ (ë³µì‚¬ë§Œ) |
| **í•™ìŠµ ê³¡ì„ ** | ê°€íŒŒë¦„ | ì™„ë§Œ (ë§ˆí¬ë‹¤ìš´ í‘œì¤€) |
| **í™•ì¥ì„±** | ì œí•œì  (í”Œë«í¼ ì¢…ì†) | ë†’ìŒ (í‘œì¤€ ê¸°ë°˜) |

### 4. ì‹¤ì œ ì‚¬ë¡€ë¡œ ì´í•´í•˜ê¸°

**ì‹œë‚˜ë¦¬ì˜¤: 100ê°œ ì‚¬ë‚´ ë§¤ë‰´ì–¼ ê´€ë¦¬**

```
Notion ë°©ì‹:
1. Notion ì—ë””í„°ë¡œ 100ê°œ í˜ì´ì§€ ì‘ì„± (40ì‹œê°„)
2. ë¸”ë¡ êµ¬ì¡° ìˆ˜ë™ ì •ë¦¬ (10ì‹œê°„)
3. í˜ì´ì§€ ê°„ ë§í¬ ìˆ˜ë™ ì—°ê²° (5ì‹œê°„)
4. AIê°€ ì½ìœ¼ë ¤ë©´ Notion APIë¡œ JSON ì¶”ì¶œ â†’ íŒŒì‹± â†’ ì •ì œ
5. ì´ ì‹œê°„: 55ì‹œê°„

ìš°ë¦¬ ë°©ì‹:
1. VSCodeë¡œ 100ê°œ .md íŒŒì¼ ì‘ì„± (40ì‹œê°„)
2. í´ë” ì—…ë¡œë“œ (5ë¶„)
3. AI ìë™ ì²˜ë¦¬:
   - ë¸”ë¡ êµ¬ì¡° ìë™ ë¶„ì„ (5ë¶„)
   - íƒœê·¸ ìë™ ì¶”ì¶œ (3ë¶„)
   - ê´€ê³„ ìë™ íŒŒì•… (2ë¶„)
   - ì¸ë±ìŠ¤ ìë™ ìƒì„± (5ë¶„)
4. ì´ ì‹œê°„: 40ì‹œê°„ 20ë¶„

ì ˆê°: 14ì‹œê°„ 40ë¶„ (27% íš¨ìœ¨ í–¥ìƒ)
+ ë°ì´í„° ì†Œìœ ê¶Œ ë³´ì¥
+ Git ë²„ì „ ê´€ë¦¬ ê°€ëŠ¥
+ ì–´ë–¤ ì—ë””í„°ë“  ì‚¬ìš© ê°€ëŠ¥
```

### 5. ê¸°ìˆ ì  ìš°ìˆ˜ì„±

**íŒŒì‹± íŒŒì´í”„ë¼ì¸ ì„±ëŠ¥:**
```typescript
// ìˆœìˆ˜ JSON ì ‘ê·¼:
Database â†’ JSON â†’ AI Processing
- DB ì½ê¸°: 100ms
- JSON íŒŒì‹±: 50ms
- AI ì²˜ë¦¬: 300ms
- ì´: 450ms

// ìš°ë¦¬ í•˜ì´ë¸Œë¦¬ë“œ:
S3 â†’ Markdown â†’ AST â†’ JSON â†’ Cached â†’ AI Processing
- S3 ì½ê¸°: 50ms (CDN ìºì‹±)
- MD íŒŒì‹±: 20ms (ì¦ë¶„ íŒŒì‹±)
- AST â†’ JSON: 30ms (ìºì‹±)
- AI ì²˜ë¦¬: 300ms (ë²¡í„° ìºì‹±)
- ì´: 400ms

â†’ ì„±ëŠ¥ ì†ì‹¤ ì—†ìŒ + ìºì‹±ìœ¼ë¡œ ì˜¤íˆë ¤ ë” ë¹ ë¦„
```

**ë¹„ìš© íš¨ìœ¨:**
```
ìˆœìˆ˜ JSON (DB ì €ì¥):
- DB ìŠ¤í† ë¦¬ì§€: $0.10/GB/ì›”
- DB I/O: $0.20/1M requests
- 100GB ë¬¸ì„œ + 1M requests/ì›” = $210/ì›”

í•˜ì´ë¸Œë¦¬ë“œ (S3 + DB):
- S3 ìŠ¤í† ë¦¬ì§€: $0.023/GB/ì›” (ì›ë³¸ .md)
- DB ìŠ¤í† ë¦¬ì§€: $0.10/GB/ì›” (ë©”íƒ€ë°ì´í„°ë§Œ)
- CloudFront: $0.085/GB (ìºì‹±)
- 100GB ë¬¸ì„œ (S3: 100GB, DB: 10GB) = $3.30/ì›”

â†’ 98% ë¹„ìš© ì ˆê°
```

### 6. ë¯¸ë˜ í™•ì¥ì„±

**í•˜ì´ë¸Œë¦¬ë“œ ì•„í‚¤í…ì²˜ì˜ ì§„í™” ê°€ëŠ¥ì„±:**

```
í˜„ì¬ (Phase 1-2):
Markdown â†’ JSON â†’ AI Processing

ë¯¸ë˜ (Phase 3+):
1. Real-time Collaboration Layer:
   Markdown â†’ Operational Transform â†’ JSON â†’ AI Processing

2. Advanced AI Features:
   Markdown â†’ Knowledge Graph â†’ Reasoning Engine â†’ AI Agents

3. Multi-modal Support:
   Markdown + Images + Videos â†’ Unified Embedding â†’ Cross-modal Search

4. Enterprise Integration:
   Markdown â†’ API Gateway â†’ ERP/CRM Integration â†’ Business Intelligence
```

**í•µì‹¬ ì›ì¹™ì€ ìœ ì§€:**
- ì‚¬ìš©ìëŠ” ì—¬ì „íˆ .md íŒŒì¼ë§Œ ë‹¤ë£¸
- ì‹œìŠ¤í…œì€ ë‚´ë¶€ì—ì„œ ì ì  ë” ë˜‘ë˜‘í•´ì§
- ë°ì´í„° ì†Œìœ ê¶Œì€ í•­ìƒ ì‚¬ìš©ìì—ê²Œ

### 7. ê²°ë¡ : "The Best of Both Worlds"

**ì´ í•˜ì´ë¸Œë¦¬ë“œ ì•„í‚¤í…ì²˜ê°€ ëª¨ë˜í•œ ì´ìœ :**

âœ… **Progressive Enhancement ì² í•™**
- ê¸°ë³¸: ë§ˆí¬ë‹¤ìš´ (ëˆ„êµ¬ë‚˜ ì‚¬ìš© ê°€ëŠ¥)
- ê°•í™”: AI ìë™ ì²˜ë¦¬ (ë³´ì´ì§€ ì•Šê²Œ ë˜‘ë˜‘í•¨)
- í™•ì¥: í•„ìš”ì— ë”°ë¼ ê¸°ëŠ¥ ì¶”ê°€ (ì‚¬ìš©ì ë¶€ë‹´ ì—†ìŒ)

âœ… **User-Centric Design**
- ì‚¬ìš©ìëŠ” ìµìˆ™í•œ ë„êµ¬ ì‚¬ìš© (VSCode, Obsidian, Typora)
- í”Œë«í¼ì€ ë³µì¡í•œ ì²˜ë¦¬ ë‹´ë‹¹ (íŒŒì‹±, ë²¡í„°í™”, AI)
- ëª…í™•í•œ ê´€ì‹¬ì‚¬ ë¶„ë¦¬ (Separation of Concerns)

âœ… **AI-First Architecture**
- ëª¨ë“  ë¬¸ì„œ ìë™ êµ¬ì¡°í™”
- ë¸”ë¡ ë‹¨ìœ„ ë²¡í„°í™”
- ì‹¤ì‹œê°„ ê´€ê³„ ë¶„ì„
- ìë™ ì¸ë±ì‹±

âœ… **Zero Lock-in Philosophy**
- ì–¸ì œë“  .md íŒŒì¼ ë‹¤ìš´ë¡œë“œ ê°€ëŠ¥
- Gitìœ¼ë¡œ ë²„ì „ ê´€ë¦¬
- ë‹¤ë¥¸ í”Œë«í¼ìœ¼ë¡œ ì´ë™ ììœ 

**í•œ ë§ˆë””ë¡œ:**
> "Notionì˜ ë˜‘ë˜‘í•¨ + GitBookì˜ ë‹¨ìˆœí•¨ + ë°ì´í„° ì†Œìœ ê¶Œ = ìš°ë¦¬ í”Œë«í¼"

ì´ê²ƒì´ 2025ë…„ í˜„ì¬, ê°€ì¥ ëª¨ë˜í•˜ê³  ì‹¤ìš©ì ì¸ ì ‘ê·¼ë²•ì…ë‹ˆë‹¤.
